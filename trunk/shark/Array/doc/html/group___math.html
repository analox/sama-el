<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Array: Mathematic Functions (Please notice the detailed description!)</title>
<link href="Array.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>Mathematic Functions (Please notice the detailed description!)<br>
<small>
[<a class="el" href="group___all_ops.html">Operations for Arrays (Please notice the detailed description!)</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gff5133315a7ae8ca658acd6f7beb5cb3">Array::transpose</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the transposition of the current array.  <a href="#gff5133315a7ae8ca658acd6f7beb5cb3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_array_index.html">ArrayIndex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#g9f83713bb0eb588c6e4f0584122f181a">operator &amp;&amp;</a> (<a class="el" href="class_array_index.html">ArrayIndex</a> &amp;a, <a class="el" href="class_array_index.html">ArrayIndex</a> &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given two index arrays "a" and "b", where the indices are stored in ascending order, an index array with all indices stored in "a" AND "b" is returned.  <a href="#g9f83713bb0eb588c6e4f0584122f181a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_array_index.html">ArrayIndex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#g7fdebcfd8d9a0e392e2e1dad0d59f999">operator||</a> (<a class="el" href="class_array_index.html">ArrayIndex</a> &amp;a, <a class="el" href="class_array_index.html">ArrayIndex</a> &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given two index arrays "a" and "b", where the indices are stored in ascending order, an index array with all indices stored in "a" OR "b" is returned.  <a href="#g7fdebcfd8d9a0e392e2e1dad0d59f999"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="class_array.html">Array</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gaf158bbc5116e70845fe5064d0c0fcf9">innerProduct</a> (const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;v, const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the inner product of the two arrays "v" and "w".  <a href="#gaf158bbc5116e70845fe5064d0c0fcf9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="class_array.html">Array</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#g3c3307028bc2a3f36c40f4038cae72b4">outerProduct</a> (const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;v, const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the outer product of the two arrays "v" and "w".  <a href="#g3c3307028bc2a3f36c40f4038cae72b4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#geb0a052627616a83babcf245d864f54a">scalarProduct</a> (const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;v, const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the scalar product of the two arrays "v" and "w".  <a href="#geb0a052627616a83babcf245d864f54a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#g7b4ace07d85f0583a8d5710b29474da9">sqrDistance</a> (const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;v, const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the square distance between the two arrays "v" and "w".  <a href="#g7b4ace07d85f0583a8d5710b29474da9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#g771fe9b9a782041223b84ec958dcd7b8">euclidianDistance</a> (const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;v, const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the euclidian distance between the two arrays "v" and "w".  <a href="#g771fe9b9a782041223b84ec958dcd7b8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gbcd6c8bbd5c7e0a48dcb2f6c5fa23e8f">sum</a> (const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the sum of all values in array "v".  <a href="#gbcd6c8bbd5c7e0a48dcb2f6c5fa23e8f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#g7780f7144658cee6b75acfb23b6251d2">sumOfAbs</a> (const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the sum of all absolute values in array "v".  <a href="#g7780f7144658cee6b75acfb23b6251d2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#g888c0469886b8f9295d1da9752c2281d">sumOfSqr</a> (const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the sum of all square values in array "v".  <a href="#g888c0469886b8f9295d1da9752c2281d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#g21b8d4be99b4047a9f46de73c10c337d">product</a> (const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the product of all values in array "v".  <a href="#g21b8d4be99b4047a9f46de73c10c337d"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The methods listed here are not complete. Most of the defined operators in file <a class="el" href="_array_op_8h.html">ArrayOp.h</a> are removed from the reference, because the special way of defining these operators causes doxygen to create a corrupted reference. A list of these operators can be found in the detailed description of <a class="el" href="_array_op_8h.html">ArrayOp.h</a>. <hr><h2>Function Documentation</h2>
<a class="anchor" name="g771fe9b9a782041223b84ec958dcd7b8"></a><!-- doxytag: member="ArrayOp.h::euclidianDistance" ref="g771fe9b9a782041223b84ec958dcd7b8" args="(const Array&lt; T &gt; &amp;v, const Array&lt; T &gt; &amp;w)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T euclidianDistance           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>w</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the euclidian distance between the two arrays "v" and "w". 
<p>
The euclidian distance <img class="formulaInl" alt="$d$" src="form_67.png"> is evaluated as<p>
<img class="formulaInl" alt="$ d = \sqrt{\sum_{i=0}^{N-1} {(v_i - w_i)}^2} $" src="form_70.png"><p>
where <img class="formulaInl" alt="$N$" src="form_69.png"> is the total number of elements in each array and the single elements are taken in the order as they are stored in the element vector <a class="el" href="class_array.html#30bef9323c490214d0db9cb0d86abd36">Array::e</a>. <br>
 Notice, that the two arrays must have the same number of elements.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>the first array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>the second array. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the euclidian distance <img class="formulaInl" alt="$d$" src="form_67.png"> </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classcheck__exception.html">check_exception</a></em>&nbsp;</td><td>the type of the exception will be "size mismatch" and indicates that the two arrays <em>v</em> and <em>w</em> have different sizes</td></tr>
  </table>
</dl>
<dl compact><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>1995</dd></dl>
<dl compact><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl compact><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>
Definition at line <a class="el" href="_array_op_8h-source.html#l00849">849</a> of file <a class="el" href="_array_op_8h-source.html">ArrayOp.h</a>.
<p>
References <a class="el" href="_array_op_8h-source.html#l00800">sqrDistance()</a>.
</div>
</div><p>
<a class="anchor" name="gaf158bbc5116e70845fe5064d0c0fcf9"></a><!-- doxytag: member="ArrayOp.h::innerProduct" ref="gaf158bbc5116e70845fe5064d0c0fcf9" args="(const Array&lt; T &gt; &amp;v, const Array&lt; T &gt; &amp;w)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_array.html">Array</a>&lt; T &gt; innerProduct           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>w</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the inner product of the two arrays "v" and "w". 
<p>
The inner product, also known as the scalar product of two vectors <img class="formulaInl" alt="$x$" src="form_45.png"> and <img class="formulaInl" alt="$y$" src="form_46.png"> with dimension <img class="formulaInl" alt="$n$" src="form_47.png"> is a scalar value <img class="formulaInl" alt="$\alpha$" src="form_48.png"> given as<p>
<img class="formulaInl" alt="$ \alpha = x^T \cdot y = \sum_{i=1}^n x_i \cdot y_i $" src="form_49.png"><p>
You can also use this method for vectors as one-dimensional arrays, but this method is a generalization of the scalar product and is especially written for N-dimensional arrays with <img class="formulaInl" alt="$N \geq 2$" src="form_50.png">. <br>
 Therefore the method will always return an array of scalar values. If you want to calculate the "original" scalar product for two vectors, it is more handy to use the method <a class="el" href="group___math.html#geb0a052627616a83babcf245d864f54a">scalarProduct</a>, because this method will return a single scalar value. <br>
 If you use arrays that represent two matrices <img class="formulaInl" alt="$A$" src="form_9.png"> with dimensions <img class="formulaInl" alt="$m_1 \times \dots \times m_k$" src="form_51.png"> and <img class="formulaInl" alt="$B$" src="form_52.png"> with dimensions <img class="formulaInl" alt="$n_1 \times \dots \times n_l$" src="form_53.png"> with <img class="formulaInl" alt="$l, k \geq 2$" src="form_54.png"> and <img class="formulaInl" alt="$m_k = n_1$" src="form_55.png"> then the result is a matrix <img class="formulaInl" alt="$C$" src="form_56.png"> with dimensions <img class="formulaInl" alt="$m_1 \times \dots \times m_{k-1} \times n_2 \times \dots \times n_l$" src="form_57.png">. Each scalar value of <img class="formulaInl" alt="$C$" src="form_56.png"> is calculated by multiplying each "row" of matrix <img class="formulaInl" alt="$A$" src="form_9.png"> with each column of matrix <img class="formulaInl" alt="$B$" src="form_52.png">, where "row" means always the first dimension of a matrix and "column" the last dimension. The multiplication results are then added together.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>the first array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>the second array. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>an array containing the inner product of <em>v</em> and <em>w</em> </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classcheck__exception.html">check_exception</a></em>&nbsp;</td><td>the type of the exception will be "size mismatch" and means that you've called the method with two one-dimensional arrays, but these vectors have different sizes</td></tr>
  </table>
</dl>
<dl compact><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>1995</dd></dl>
<dl compact><dt><b>Changes</b></dt><dd>2002-03-21, ra: Method crashed, when two one-dimensional arrays were used. Now the method "scalarProduct" is called in this case and the result is casted into an array.</dd></dl>
<dl compact><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>
Definition at line <a class="el" href="_array_op_8h-source.html#l00552">552</a> of file <a class="el" href="_array_op_8h-source.html">ArrayOp.h</a>.
<p>
References <a class="el" href="_array_8h-source.html#l00558">ArrayBase::dim()</a>, <a class="el" href="_array_8h-source.html#l01793">Array&lt; T &gt;::elem()</a>, <a class="el" href="_array_8h-source.html#l00269">ArrayBase::ndim()</a>, <a class="el" href="_array_8h-source.html#l00295">ArrayBase::nelem()</a>, <a class="el" href="_array_8h-source.html#l00366">ArrayBase::resize()</a>, <a class="el" href="_array_op_8h-source.html#l00756">scalarProduct()</a>, and <a class="el" href="_array_check_8h-source.html#l00247">SIZE_CHECK</a>.
</div>
</div><p>
<a class="anchor" name="g9f83713bb0eb588c6e4f0584122f181a"></a><!-- doxytag: member="ArrayIndexOp.h::operator &amp;&amp;" ref="g9f83713bb0eb588c6e4f0584122f181a" args="(ArrayIndex &amp;a, ArrayIndex &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_array_index.html">ArrayIndex</a> operator &amp;&amp;           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_array_index.html">ArrayIndex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_array_index.html">ArrayIndex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given two index arrays "a" and "b", where the indices are stored in ascending order, an index array with all indices stored in "a" AND "b" is returned. 
<p>
For sorting the index arrays, use function "sort" in <a class="el" href="_array_sort_8h.html">ArraySort.h</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>the first index array, whose indices are compared to those of <em>b</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>the second index array, whose indices are compared to those of <em>a</em> </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>index array with all indices, that are stored in <em>a</em> AND <em>b</em> </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classcheck__exception.html">check_exception</a></em>&nbsp;</td><td>the type of the exception will be "size mismatch" and indicates that <em>a</em> or <em>b</em> are not one-dimensional</td></tr>
  </table>
</dl>
<dl compact><dt><b>Author:</b></dt><dd>D. Homberg </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>????</dd></dl>
<dl compact><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl compact><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>
Definition at line <a class="el" href="_array_index_op_8h-source.html#l00397">397</a> of file <a class="el" href="_array_index_op_8h-source.html">ArrayIndexOp.h</a>.
<p>
References <a class="el" href="_array_index_8h-source.html#l00646">ArrayIndex::add()</a>, and <a class="el" href="_array_index_8h-source.html#l00413">ArrayIndex::getPos()</a>.
</div>
</div><p>
<a class="anchor" name="g7fdebcfd8d9a0e392e2e1dad0d59f999"></a><!-- doxytag: member="ArrayIndexOp.h::operator||" ref="g7fdebcfd8d9a0e392e2e1dad0d59f999" args="(ArrayIndex &amp;a, ArrayIndex &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_array_index.html">ArrayIndex</a> operator||           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_array_index.html">ArrayIndex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_array_index.html">ArrayIndex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given two index arrays "a" and "b", where the indices are stored in ascending order, an index array with all indices stored in "a" OR "b" is returned. 
<p>
If an index value is stored in <em>a</em> and <em>b</em>, then it is only stored once in the returned index array. <br>
 For sorting the index arrays, use function "sort" in <a class="el" href="_array_sort_8h.html">ArraySort.h</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>the first index array, whose indices are compared to those of <em>b</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>the second index array, whose indices are compared to those of <em>a</em> </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>index array with all indices, that are stored in <em>a</em> OR <em>b</em> </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classcheck__exception.html">check_exception</a></em>&nbsp;</td><td>the type of the exception will be "size mismatch" and indicates that <em>a</em> or <em>b</em> are not one-dimensional</td></tr>
  </table>
</dl>
<dl compact><dt><b>Author:</b></dt><dd>D. Homberg </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>????</dd></dl>
<dl compact><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl compact><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>
Definition at line <a class="el" href="_array_index_op_8h-source.html#l00455">455</a> of file <a class="el" href="_array_index_op_8h-source.html">ArrayIndexOp.h</a>.
<p>
References <a class="el" href="_array_index_8h-source.html#l00646">ArrayIndex::add()</a>, and <a class="el" href="_array_index_8h-source.html#l00413">ArrayIndex::getPos()</a>.
</div>
</div><p>
<a class="anchor" name="g3c3307028bc2a3f36c40f4038cae72b4"></a><!-- doxytag: member="ArrayOp.h::outerProduct" ref="g3c3307028bc2a3f36c40f4038cae72b4" args="(const Array&lt; T &gt; &amp;v, const Array&lt; T &gt; &amp;w)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_array.html">Array</a>&lt; T &gt; outerProduct           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>w</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the outer product of the two arrays "v" and "w". 
<p>
The outer product, also known as the dyadic product of a vector <img class="formulaInl" alt="$x$" src="form_45.png"> with dimension <img class="formulaInl" alt="$m$" src="form_58.png"> and a vector <img class="formulaInl" alt="$y$" src="form_46.png"> with dimension <img class="formulaInl" alt="$n$" src="form_47.png"> is a matrix <img class="formulaInl" alt="$A$" src="form_9.png"> given as<p>
<img class="formulaInl" alt="$ A = x \cdot y^T $" src="form_59.png"><p>
where <img class="formulaInl" alt="$A$" src="form_9.png"> is a <img class="formulaInl" alt="$m \times n$" src="form_60.png"> matrix with <img class="formulaInl" alt="$a_{ij} = x_i \cdot y_j$" src="form_61.png"> for <img class="formulaInl" alt="$i = 1, \dots, m$" src="form_62.png"> and <img class="formulaInl" alt="$j = 1, \dots, n$" src="form_63.png">. <br>
 This method is a generalization, it works not only for vectors as one-dimensional arrays, but also for N-dimensional arrays with <img class="formulaInl" alt="$N \geq 2$" src="form_50.png">. <br>
 Given two matrices <img class="formulaInl" alt="$A$" src="form_9.png"> with dimensions <img class="formulaInl" alt="$m_1 \times \dots \times m_k$" src="form_51.png"> and <img class="formulaInl" alt="$B$" src="form_52.png"> with dimensions <img class="formulaInl" alt="$n_1 \times \dots \times n_l$" src="form_53.png"> the result is an matrix <img class="formulaInl" alt="$C$" src="form_56.png"> with dimensions <img class="formulaInl" alt="$m_1 \times \dots \times m_k \times n_1 \times \dots \times n_l$" src="form_64.png">, where <img class="formulaInl" alt="$c_{i_1 \dots i_k i_{k+1} \dots i_{k+l}} = a_{i_1 \dots i_k} \cdot b_{i_{k+1} \dots i_{k+l}}$" src="form_65.png"> for <img class="formulaInl" alt="$i_1 = 1, \dots, m_1\mbox{;\ } \dots \mbox{;\ }i_k = 1, \dots, m_k\mbox{;\ }i_{k+1} = 1, \dots, n_1\mbox{;\ } \dots \mbox{;\ }i_{k+l} = 1, \dots, n_l$" src="form_66.png"><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>the first array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>the second array. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>an array containing the outer product of <em>v</em> and <em>w</em> </dd></dl>
<dl compact><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>1995</dd></dl>
<dl compact><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl compact><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>
Definition at line <a class="el" href="_array_op_8h-source.html#l00661">661</a> of file <a class="el" href="_array_op_8h-source.html">ArrayOp.h</a>.
<p>
References <a class="el" href="_array_8h-source.html#l00558">ArrayBase::dim()</a>, <a class="el" href="_array_8h-source.html#l01793">Array&lt; T &gt;::elem()</a>, <a class="el" href="_array_8h-source.html#l00269">ArrayBase::ndim()</a>, <a class="el" href="_array_8h-source.html#l00295">ArrayBase::nelem()</a>, and <a class="el" href="_array_8h-source.html#l00366">ArrayBase::resize()</a>.
</div>
</div><p>
<a class="anchor" name="g21b8d4be99b4047a9f46de73c10c337d"></a><!-- doxytag: member="ArrayOp.h::product" ref="g21b8d4be99b4047a9f46de73c10c337d" args="(const Array&lt; T &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T product           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the product of all values in array "v". 
<p>
The product is evaluated as<p>
<img class="formulaInl" alt="$ t = \prod_{i=0}^{N-1} v_i $" src="form_75.png"><p>
where <img class="formulaInl" alt="$N$" src="form_69.png"> is the total number of values in the array and the single values are taken in the order as they are stored in the element vector <a class="el" href="class_array.html#30bef9323c490214d0db9cb0d86abd36">Array::e</a>. <br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>the array of which the product will be calculated </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the product <img class="formulaInl" alt="$t$" src="form_72.png"></dd></dl>
<dl compact><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>1995</dd></dl>
<dl compact><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl compact><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>
Definition at line <a class="el" href="_array_op_8h-source.html#l00994">994</a> of file <a class="el" href="_array_op_8h-source.html">ArrayOp.h</a>.
<p>
References <a class="el" href="_array_8h-source.html#l01793">Array&lt; T &gt;::elem()</a>, and <a class="el" href="_array_8h-source.html#l00295">ArrayBase::nelem()</a>.
</div>
</div><p>
<a class="anchor" name="geb0a052627616a83babcf245d864f54a"></a><!-- doxytag: member="ArrayOp.h::scalarProduct" ref="geb0a052627616a83babcf245d864f54a" args="(const Array&lt; T &gt; &amp;v, const Array&lt; T &gt; &amp;w)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T scalarProduct           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>w</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the scalar product of the two arrays "v" and "w". 
<p>
The scalar product, also known as the inner product of two vectors <img class="formulaInl" alt="$x$" src="form_45.png"> and <img class="formulaInl" alt="$y$" src="form_46.png"> with dimension <img class="formulaInl" alt="$n$" src="form_47.png"> is a scalar value <img class="formulaInl" alt="$\alpha$" src="form_48.png"> given as<p>
<img class="formulaInl" alt="$ \alpha = x^T \cdot y = \sum_{i=1}^n x_i \cdot y_i $" src="form_49.png"><p>
Here, the two arrays <em>v</em> and <em>w</em> are interpreted as one-dimensional arrays, by using the element vectors <a class="el" href="class_array.html#30bef9323c490214d0db9cb0d86abd36">Array::e</a> of both. So you can use this method for two N-dimensional arrays with <img class="formulaInl" alt="$N \geq 2$" src="form_50.png">, but will always receive a single scalar value. <br>
 If you want to calculate the inner product for those arrays with respect to the number of dimensions, use method <a class="el" href="group___math.html#gaf158bbc5116e70845fe5064d0c0fcf9">innerProduct</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>the first array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>the second array. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the scalar product <img class="formulaInl" alt="$\alpha$" src="form_48.png"> of the element vectors of the two arrays </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classcheck__exception.html">check_exception</a></em>&nbsp;</td><td>the type of the exception will be "size mismatch" and means that the two vectors have different sizes</td></tr>
  </table>
</dl>
<dl compact><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>1995</dd></dl>
<dl compact><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl compact><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>
Definition at line <a class="el" href="_array_op_8h-source.html#l00756">756</a> of file <a class="el" href="_array_op_8h-source.html">ArrayOp.h</a>.
<p>
References <a class="el" href="_array_8h-source.html#l01793">Array&lt; T &gt;::elem()</a>, <a class="el" href="_array_8h-source.html#l00295">ArrayBase::nelem()</a>, <a class="el" href="_array_8h-source.html#l00325">ArrayBase::samedim()</a>, and <a class="el" href="_array_check_8h-source.html#l00247">SIZE_CHECK</a>.
<p>
Referenced by <a class="el" href="_array_op_8h-source.html#l00552">innerProduct()</a>.
</div>
</div><p>
<a class="anchor" name="g7b4ace07d85f0583a8d5710b29474da9"></a><!-- doxytag: member="ArrayOp.h::sqrDistance" ref="g7b4ace07d85f0583a8d5710b29474da9" args="(const Array&lt; T &gt; &amp;v, const Array&lt; T &gt; &amp;w)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T sqrDistance           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>w</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the square distance between the two arrays "v" and "w". 
<p>
The square distance <img class="formulaInl" alt="$d$" src="form_67.png"> is evaluated as<p>
<img class="formulaInl" alt="$ d = \sum_{i=0}^{N-1} {(v_i - w_i)}^2 $" src="form_68.png"><p>
where <img class="formulaInl" alt="$N$" src="form_69.png"> is the total number of elements in each array and the single elements are taken in the order as they are stored in the element vector <a class="el" href="class_array.html#30bef9323c490214d0db9cb0d86abd36">Array::e</a>. <br>
 Notice, that the two arrays must have the same number of elements.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>the first array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>the second array. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the square distance <img class="formulaInl" alt="$d$" src="form_67.png"> </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classcheck__exception.html">check_exception</a></em>&nbsp;</td><td>the type of the exception will be "size mismatch" and indicates that the two arrays <em>v</em> and <em>w</em> have different sizes</td></tr>
  </table>
</dl>
<dl compact><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>1995</dd></dl>
<dl compact><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl compact><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>
Definition at line <a class="el" href="_array_op_8h-source.html#l00800">800</a> of file <a class="el" href="_array_op_8h-source.html">ArrayOp.h</a>.
<p>
References <a class="el" href="_array_8h-source.html#l01793">Array&lt; T &gt;::elem()</a>, <a class="el" href="_array_8h-source.html#l00295">ArrayBase::nelem()</a>, <a class="el" href="_array_8h-source.html#l00325">ArrayBase::samedim()</a>, and <a class="el" href="_array_check_8h-source.html#l00247">SIZE_CHECK</a>.
<p>
Referenced by <a class="el" href="_array_op_8h-source.html#l00849">euclidianDistance()</a>.
</div>
</div><p>
<a class="anchor" name="gbcd6c8bbd5c7e0a48dcb2f6c5fa23e8f"></a><!-- doxytag: member="ArrayOp.h::sum" ref="gbcd6c8bbd5c7e0a48dcb2f6c5fa23e8f" args="(const Array&lt; T &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T sum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the sum of all values in array "v". 
<p>
The sum is evaluated as<p>
<img class="formulaInl" alt="$ t = \sum_{i=0}^{N-1} v_i $" src="form_71.png"><p>
where <img class="formulaInl" alt="$N$" src="form_69.png"> is the total number of values in the array and the single values are taken in the order as they are stored in the element vector <a class="el" href="class_array.html#30bef9323c490214d0db9cb0d86abd36">Array::e</a>. <br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>the array of which the sum will be calculated </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the sum <img class="formulaInl" alt="$t$" src="form_72.png"></dd></dl>
<dl compact><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>1995</dd></dl>
<dl compact><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl compact><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>
Definition at line <a class="el" href="_array_op_8h-source.html#l00884">884</a> of file <a class="el" href="_array_op_8h-source.html">ArrayOp.h</a>.
<p>
References <a class="el" href="_array_8h-source.html#l01793">Array&lt; T &gt;::elem()</a>, and <a class="el" href="_array_8h-source.html#l00295">ArrayBase::nelem()</a>.
</div>
</div><p>
<a class="anchor" name="g7780f7144658cee6b75acfb23b6251d2"></a><!-- doxytag: member="ArrayOp.h::sumOfAbs" ref="g7780f7144658cee6b75acfb23b6251d2" args="(const Array&lt; T &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T sumOfAbs           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the sum of all absolute values in array "v". 
<p>
The sum is evaluated as<p>
<img class="formulaInl" alt="$ t = \sum_{i=0}^{N-1} |v_i| $" src="form_73.png"><p>
where <img class="formulaInl" alt="$N$" src="form_69.png"> is the total number of values in the array and the single values are taken in the order as they are stored in the element vector <a class="el" href="class_array.html#30bef9323c490214d0db9cb0d86abd36">Array::e</a>. <br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>the array of which the sum will be calculated </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the sum <img class="formulaInl" alt="$t$" src="form_72.png"></dd></dl>
<dl compact><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>1995</dd></dl>
<dl compact><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl compact><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>
Definition at line <a class="el" href="_array_op_8h-source.html#l00920">920</a> of file <a class="el" href="_array_op_8h-source.html">ArrayOp.h</a>.
<p>
References <a class="el" href="_array_8h-source.html#l01793">Array&lt; T &gt;::elem()</a>, and <a class="el" href="_array_8h-source.html#l00295">ArrayBase::nelem()</a>.
</div>
</div><p>
<a class="anchor" name="g888c0469886b8f9295d1da9752c2281d"></a><!-- doxytag: member="ArrayOp.h::sumOfSqr" ref="g888c0469886b8f9295d1da9752c2281d" args="(const Array&lt; T &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T sumOfSqr           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the sum of all square values in array "v". 
<p>
The sum is evaluated as<p>
<img class="formulaInl" alt="$ t = \sum_{i=0}^{N-1} v_i^2 $" src="form_74.png"><p>
where <img class="formulaInl" alt="$N$" src="form_69.png"> is the total number of values in the array and the single values are taken in the order as they are stored in the element vector <a class="el" href="class_array.html#30bef9323c490214d0db9cb0d86abd36">Array::e</a>. <br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>the array of which the sum will be calculated </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the sum <img class="formulaInl" alt="$t$" src="form_72.png"></dd></dl>
<dl compact><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>1995</dd></dl>
<dl compact><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl compact><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>
Definition at line <a class="el" href="_array_op_8h-source.html#l00957">957</a> of file <a class="el" href="_array_op_8h-source.html">ArrayOp.h</a>.
<p>
References <a class="el" href="_array_8h-source.html#l01793">Array&lt; T &gt;::elem()</a>, and <a class="el" href="_array_8h-source.html#l00295">ArrayBase::nelem()</a>.
</div>
</div><p>
<a class="anchor" name="gff5133315a7ae8ca658acd6f7beb5cb3"></a><!-- doxytag: member="Array::transpose" ref="gff5133315a7ae8ca658acd6f7beb5cb3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_array.html">Array</a>&lt; T &gt;&amp; <a class="el" href="class_array.html">Array</a>&lt; T &gt;::transpose           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the transposition of the current array. 
<p>
See the current array as matrix <img class="formulaInl" alt="$A$" src="form_9.png">, then the transposed matrix <img class="formulaInl" alt="$A^T$" src="form_31.png"> is returned.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the transposed array</dd></dl>
<dl compact><dt><b>Example</b></dt><dd>Given an array with the content <br>
</dd></dl>
<img class="formulaInl" alt="$ \left(\begin{array}{lll} 1 &amp; 2 &amp; 3\\ 4 &amp; 5 &amp; 6\\ \end{array}\right) $" src="form_32.png"><p>
then the transposed array will be <br>
<p>
<img class="formulaInl" alt="$ \left(\begin{array}{ll} 1 &amp; 4\\ 2 &amp; 5\\ 3 &amp; 6 \end{array}\right) $" src="form_33.png"><p>
<dl compact><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>1995-01-01</dd></dl>
<dl compact><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl compact><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>
Definition at line <a class="el" href="_array_8h-source.html#l03939">3939</a> of file <a class="el" href="_array_8h-source.html">Array.h</a>.
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Wed Dec 16 13:06:17 2009 for Array by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
