<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>approx.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">include</a></div>
<h1>approx.h</h1><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#ifndef APPROX_H</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define APPROX_H</span>
00003 <span class="preprocessor"></span>
00004 <span class="preprocessor">#include &lt;cmath&gt;</span>
00005 <span class="preprocessor">#include "maps_general.h"</span>
00006 <span class="preprocessor">#include &lt;iostream&gt;</span>
00007 
00008 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00009 
00010 <span class="comment">/*</span>
00011 <span class="comment">#ifndef BOOL_C</span>
00012 <span class="comment">#define BOOL_C</span>
00013 <span class="comment">int TRUE = 1;</span>
00014 <span class="comment">int FALSE = 0;</span>
00015 <span class="comment">#endif</span>
00016 <span class="comment">*/</span>
00017 <span class="preprocessor">#ifndef PI_C</span>
00018 <span class="preprocessor"></span><span class="preprocessor">#define PI_C</span>
00019 <span class="preprocessor"></span><span class="keywordtype">double</span> PI = 3.1415926535897932384;
00020 <span class="preprocessor">#endif</span>
00021 <span class="preprocessor"></span>
00022  <span class="keywordtype">int</span> DEFAULTPOINTS = 25;
00023 
00024 
00025 <span class="comment">/* Choose the appropriate machine epsilon for your system, or declare one with</span>
00026 <span class="comment">   the appropriate value.  If you don't know machine epsilon, it's easy to find:</span>
00027 <span class="comment"></span>
00028 <span class="comment">   macheps = 1;</span>
00029 <span class="comment">   do {</span>
00030 <span class="comment">      macheps = macheps/2.0;</span>
00031 <span class="comment">   } while ( 1+macheps &gt; 1);</span>
00032 <span class="comment">   macheps = macheps*2.0;</span>
00033 <span class="comment"></span>
00034 <span class="comment">   Or else just simply choose the MACHEPS = 1.0 option and the program will run</span>
00035 <span class="comment">   automatically to find the correct machine epsilon.</span>
00036 <span class="comment">*/</span>
00037 
00038 <span class="keyword">class </span>approx { <span class="comment">// abstract base class</span>
00039 <span class="keyword">public</span>:
00040 
00041   approx();
00042   <span class="keyword">virtual</span> ~approx();
00043   
00044   <span class="comment">// evalf returns the value of the function at the point passed in </span>
00045   <span class="keyword">virtual</span> <span class="keywordtype">double</span> evalf(<span class="keyword">const</span> Vector&lt;double&gt;&amp; point) = 0;
00046   <span class="comment">// point is a p-dim vector at which f is to be evaluated</span>
00047   
00048   <span class="keyword">virtual</span> <span class="keywordtype">int</span> setvalues() = 0;  <span class="comment">// This is an I/O function to interactively set the</span>
00049                              <span class="comment">// necessary parameters</span>
00050 
00051   <span class="keyword">virtual</span> <span class="keywordtype">int</span> setvalues(<span class="keywordtype">char</span>* filename) = 0;
00052    <span class="comment">/* Reads the parameter values in order from a file and runs approximate() to</span>
00053 <span class="comment">      build the approximation</span>
00054 <span class="comment">      Returns 1 if successful, and 0 if insufficient data in the file.</span>
00055 <span class="comment">      Format is the same as the above.</span>
00056 <span class="comment">   */</span>
00057 
00058   <span class="comment">// functions to get copies of the data members</span>
00059   <span class="keywordtype">long</span> getp();
00060   <span class="keywordtype">long</span> getn();
00061   
00062   Matrix&lt;double&gt; getPoints();
00063   Vector&lt;double&gt; getValues();
00064 
00065   <span class="keyword">virtual</span> <span class="keywordtype">void</span> storeApprox( ostream&amp; outf ) = 0;
00066 <span class="comment">/****</span>
00067 <span class="comment">     Prints the data of the approximation to the output stream in the same format as it</span>
00068 <span class="comment">     would be read in from a file.  Thus, this function is appropriate for</span>
00069 <span class="comment">     storing functions so that they might be re-created later.</span>
00070 <span class="comment">****/</span>
00071   
00072 <span class="keyword">protected</span>:
00073   
00074   <span class="keywordtype">void</span> notseterror();
00075   <span class="keyword">virtual</span> <span class="keywordtype">void</span> deleteall() = 0;  <span class="comment">// deallocates any dynamically allocated members and sets</span>
00076   <span class="comment">// them to NULL</span>
00077 
00078   <span class="keywordtype">int</span> <span class="keyword">virtual</span> approximate() = 0;  <span class="comment">// creates the approximation using the current values</span>
00079   <span class="comment">// Returns TRUE if Successful, FALSE otherwise.</span>
00080 
00081   <span class="keywordtype">bool</span> ValuesSet;
00082   <span class="keywordtype">long</span> p;        <span class="comment">// dimension of the space</span>
00083   <span class="keywordtype">long</span> n;        <span class="comment">// number of sites</span>
00084   
00085   Matrix&lt;double&gt; X;  <span class="comment">// n p-dimensional points (resized as necessary)</span>
00086   Vector&lt;double&gt; y;  <span class="comment">// function values for the points in X     </span>
00087 }; <span class="comment">// end class approx</span>
00088 
00089 
00090 <span class="keywordtype">void</span> scanfunction( approx&amp; Func, ostream&amp; outf, <span class="keywordtype">long</span> pointsperaxis,
00091                    Vector&lt;double&gt;&amp; lower, Vector&lt;double&gt;&amp; upper);
00092 <span class="comment">/**** </span>
00093 <span class="comment">      INPUT: The krigapprox object to be sampled and an ofstream to output the</span>
00094 <span class="comment">      values, as well as the number of points per axis to be sampled.  Thus, the</span>
00095 <span class="comment">      total number of sample points is approximately (pointsperaxis)^p.  Should</span>
00096 <span class="comment">      work for any value of p.</span>
00097 <span class="comment">      </span>
00098 <span class="comment">      Bound is a 2 x p matrix, with the lower Bound in the first row and the</span>
00099 <span class="comment">      upper Bound in the second row.</span>
00100 <span class="comment"></span>
00101 <span class="comment">      EFFECT: Outputs to the stream values in columns by axis.  For example:</span>
00102 <span class="comment"></span>
00103 <span class="comment">      2.3 3.4 13.695</span>
00104 <span class="comment">      </span>
00105 <span class="comment">      would correspond to the point (2.3, 3.4, 13.695) on the Cartesian</span>
00106 <span class="comment">      coordinate system.</span>
00107 <span class="comment"></span>
00108 <span class="comment">****/</span>
00109 
00110 <span class="keywordtype">void</span> scanfunction( approx&amp; Func, ostream&amp; outf, Vector&lt;double&gt;&amp; lower, Vector&lt;double&gt;&amp; upper);
00111 <span class="comment">// A default version which uses 25 pointsperaxis.  You can modify this default</span>
00112 <span class="comment">// by changing the 25 above.</span>
00113 
00114 <span class="keywordtype">double</span> reportsample( approx&amp; Func, Vector&lt;double&gt;&amp; x, ostream&amp; outf);
00115 <span class="comment">/****</span>
00116 <span class="comment">     INPUT: The krigapprox object to be sampled, the point at which to evaluate</span>
00117 <span class="comment">     the function, and the output stream to which it should report. </span>
00118 <span class="comment">     OUTPUT: the value of the function at x - result of Func.evalf(x)</span>
00119 <span class="comment">     EFFECT: Outputs to the stream the elements of x, seperated by spaces, and</span>
00120 <span class="comment">     then the function value at x, followed by an endline. For example:</span>
00121 <span class="comment"></span>
00122 <span class="comment">     1.0 2.0 3.0 4.0 5.0 6.0 21.0</span>
00123 <span class="comment"></span>
00124 <span class="comment">     would be written if x == (1.0, 2.0, 3.0, 4.0, 5.0, 6.0) and f(x) == 21.0</span>
00125 <span class="comment"></span>
00126 <span class="comment">****/</span>
00127 
00128 <span class="keywordtype">void</span> scanplane( approx&amp; Func, ostream&amp; outf, <span class="keywordtype">long</span> pointsperaxis,
00129                 Vector&lt;double&gt;&amp; lower, Vector&lt;double&gt;&amp; upper );
00130 <span class="comment">/**** </span>
00131 <span class="comment">      A simplified, but faster version of scanfunction().</span>
00132 <span class="comment">      ONLY works when p=2 !!!</span>
00133 <span class="comment">      </span>
00134 <span class="comment"></span>
00135 <span class="comment">      INPUT: The krigapprox object to be sampled and an ofstream to output the</span>
00136 <span class="comment">      values.</span>
00137 <span class="comment"></span>
00138 <span class="comment">      Bound is a 2 x p matrix, with the lower Bound in the first row and the</span>
00139 <span class="comment">      upper Bound in the second row.</span>
00140 <span class="comment">      </span>
00141 <span class="comment">      EFFECT: Outputs to the stream values in columns by axis.  For example:</span>
00142 <span class="comment"></span>
00143 <span class="comment">      2.3 3.4 13.695</span>
00144 <span class="comment">      </span>
00145 <span class="comment">      would correspond to the point (2.3, 3.4, 13.695) on the Cartesian</span>
00146 <span class="comment">      coordinate system. </span>
00147 <span class="comment">****/</span>
00148 
00149 <span class="keywordtype">void</span> analyzevalues( approx&amp; Func, ostream&amp; outf, Vector&lt;double&gt;&amp; lower, Vector&lt;double&gt;&amp; upper );
00150 <span class="comment">/****</span>
00151 <span class="comment">     Works much like scanfunction, except that it reports simple statistics on</span>
00152 <span class="comment">     the points sampled to standard I/O, such as maximum value, minimum value,</span>
00153 <span class="comment">     average value, and the approximate location of the 25th and 75th</span>
00154 <span class="comment">     percentiles.</span>
00155 <span class="comment"></span>
00156 <span class="comment">     Uses a default value of 25 points per axis.</span>
00157 <span class="comment">     </span>
00158 <span class="comment">     Warning:  This function stores all sampled points in memory.  In higher</span>
00159 <span class="comment">     dimensions, this may fill up the available memory.  Use at your own risk.</span>
00160 <span class="comment"></span>
00161 <span class="comment">     </span>
00162 <span class="comment">****/</span>
00163 
00164 <span class="keywordtype">void</span> analyzevalues( approx&amp; Func, ostream&amp; outf, <span class="keywordtype">long</span> pointsperaxis,
00165                     Vector&lt;double&gt;&amp; lower, Vector&lt;double&gt;&amp; upper );
00166 <span class="comment">/****</span>
00167 <span class="comment">     Works much like scanfunction, except that it reports simple statistics on</span>
00168 <span class="comment">     the points sampled to standard I/O, such as maximum value, minimum value,</span>
00169 <span class="comment">     average value, and the approximate location of the 25th and 75th</span>
00170 <span class="comment">     percentiles.</span>
00171 <span class="comment"></span>
00172 <span class="comment">     Divides each axis into pointsperaxis evenly spaced points, and samples at</span>
00173 <span class="comment">     each permutation of values.</span>
00174 <span class="comment">     </span>
00175 <span class="comment">     Warning:  This function stores all sampled points in memory.  In higher</span>
00176 <span class="comment">     dimensions, this may fill up the available memory.  Use at your own risk.</span>
00177 <span class="comment">****/</span>
00178 
00179 <span class="preprocessor">#endif</span>
00180 <span class="preprocessor"></span>
00181 
00182 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Sep 25 17:37:40 2007 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
