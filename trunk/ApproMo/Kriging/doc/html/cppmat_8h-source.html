<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>cppmat.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">include</a></div>
<h1>cppmat.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">// Template Numerical Toolkit (TNT) for Linear Algebra</span>
00002 <span class="comment">//</span>
00003 <span class="comment">// BETA VERSION INCOMPLETE AND SUBJECT TO CHANGE</span>
00004 <span class="comment">// Please see http://math.nist.gov/tnt for updates</span>
00005 <span class="comment">//</span>
00006 <span class="comment">// R. Pozo</span>
00007 <span class="comment">// Mathematical and Computational Sciences Division</span>
00008 <span class="comment">// National Institute of Standards and Technology</span>
00009 
00010 <span class="comment">// Modified 6/2003 to make it work with new compilers,</span>
00011 <span class="comment">//   and renamed.</span>
00012 <span class="comment">//      P.L. (Anne) Shepherd</span>
00013 
00014 <span class="comment">// ***********************************************************</span>
00015 <span class="comment">// ****IMPORTANT NOTE:</span>
00016 <span class="comment">//     This file is a child of our old cmat.h file, ***BUT***</span>
00017 <span class="comment">//     I have modified this code so the overloaded reference</span>
00018 <span class="comment">//         operator () has C-type 0-based indexing.  This is </span>
00019 <span class="comment">//         a CHANGE from the original, which uses Fortran-type</span>
00020 <span class="comment">//         1-based indexing.  Any program that calls the operator</span>
00021 <span class="comment">//         in this version of cppmat.h expecting 1-based indexing,</span>
00022 <span class="comment">//         or uses an old version of cppmat.h and expects 0-based</span>
00023 <span class="comment">//         indexing, will get BAD RESULTS.  Please BE SURE</span>
00024 <span class="comment">//         you know which version of cppmat.h you are using and </span>
00025 <span class="comment">//         which one you need to be using.</span>
00026 <span class="comment">//           ----Anne Shepherd, 6/17/03   ********************</span>
00027 <span class="comment">// ***********************************************************</span>
00028 
00029 <span class="comment">// C compatible matrix: row-oriented, 0-based [i][j] and  (i,j) indexing</span>
00030 <span class="comment">//</span>
00031 <span class="comment">// Chris Siefert's modified namespace free version - 5/26/99</span>
00032 <span class="comment">// function (row) has been added.  </span>
00033 <span class="comment">//    It returns the vector that contains that row.</span>
00034 <span class="comment">// function (col) has been added.  </span>
00035 <span class="comment">//    It returns the vector that contains that column.</span>
00036 <span class="comment">// Also, support for multiplication by a scalar has been added.</span>
00037 <span class="comment">// Support for Vector * Matrix acting as if the vector was a row </span>
00038 <span class="comment">//    vector is added.</span>
00039 <span class="comment">//</span>
00040 <span class="comment">// Added line for namespace std 6/2003 Anne Shepherd</span>
00041 
00042 <span class="comment">//Since Mr. Pozo never did it, here is the complete catalog of outside</span>
00043 <span class="comment">//accessable Matrix operations:</span>
00044 <span class="comment">//</span>
00045 <span class="comment">// Matrix&lt;T&gt;&amp; newsize(Subscript M, Subscript N) - resize matrix</span>
00046 <span class="comment">// operator T**(){ return  row_;} - ???</span>
00047 <span class="comment">// Subscript size() const { return mn_; }</span>
00048 <span class="comment">// operator = Matrix</span>
00049 <span class="comment">// operator = scalar - assigns all elements to the scalar.</span>
00050 <span class="comment">// Subscript dim(Subscript d)</span>
00051 <span class="comment">// num_rows() </span>
00052 <span class="comment">// num_cols() </span>
00053 <span class="comment">// operator[](Subscript i)</span>
00054 <span class="comment">// operator()(Subscript i)</span>
00055 <span class="comment">// operator()(Subscript i, Subscript j)</span>
00056 <span class="comment">// ostream &lt;&lt; Matrix</span>
00057 <span class="comment">// istream &gt;&gt; Matrix</span>
00058 <span class="comment">// Region operator()(const Index1D &amp;I, const Index1D &amp;J) - ???</span>
00059 <span class="comment">// Matrix + Matrix</span>
00060 <span class="comment">// Matrix - Matrix</span>
00061 <span class="comment">// mult_element(A,B) - element by element multiplication</span>
00062 <span class="comment">// transpose(A) - matrix transposition</span>
00063 <span class="comment">// Matrix * Matrix (also matmult)</span>
00064 <span class="comment">// matmult(C, B, A) - result stored in C</span>
00065 <span class="comment">// Matrix * Vector (also matmult)</span>
00066 
00067 <span class="comment">// Chris Siefert Additions:</span>
00068 <span class="comment">// row(i) - returns a Vector containing the ith row.</span>
00069 <span class="comment">// col(i) - returns a Vector containing the ith column.</span>
00070 <span class="comment">// Matrix * Scalar, Scalar * Matrix (also scalmult, 1st form only).</span>
00071 <span class="comment">// Vector * Matrix (also matmult).  Pretends vector is a row vector.</span>
00072 <span class="comment">//</span>
00073 <span class="comment">// Modified 7/00 by Anne Shepherd to allow for different implementations</span>
00074 <span class="comment">// of the operators new and new[].  If your compiler does not support the</span>
00075 <span class="comment">// ANSI Standard try-catch syntax, compile with -DDOLD_ALLOC flag or just </span>
00076 <span class="comment">// #define DOLD_ALLOC in your file before including our files.</span>
00077 
00078 <span class="preprocessor">#ifndef CMAT_cms_pls_H</span>
00079 <span class="preprocessor"></span><span class="preprocessor">#define CMAT_cms_pls_H</span>
00080 <span class="preprocessor"></span>
00081 <span class="preprocessor">#ifndef DOLD_ALLOC</span>
00082 <span class="preprocessor"></span><span class="preprocessor">#include &lt;new&gt;</span>
00083 <span class="preprocessor">#endif</span>
00084 <span class="preprocessor"></span>
00085 <span class="preprocessor">#include "vec.h"</span>
00086 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
00087 <span class="preprocessor">#include &lt;cassert&gt;</span>
00088 
00089 <span class="preprocessor">#include &lt;iostream&gt;</span>
00090 <span class="preprocessor">#ifdef TNT_USE_REGIONS</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#include "region2d.h"</span>
00092 <span class="preprocessor">#endif</span>
00093 <span class="preprocessor"></span>
00094 <span class="preprocessor">#include &lt;iomanip&gt;</span>
00095 <span class="preprocessor">#define D_PRECISION 16</span>
00096 <span class="preprocessor"></span>
00097 
00098 <span class="comment">//namespace TNT</span>
00099 <span class="comment">//{</span>
00100 <span class="keyword">typedef</span> <span class="keywordtype">long</span> Subscript;
00101 
00102 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00103 <span class="keyword">class </span>Matrix 
00104 {
00105 
00106 
00107   <span class="keyword">public</span>:
00108 
00109     <span class="keyword">typedef</span> Subscript   size_type;
00110     <span class="keyword">typedef</span>         T   value_type;
00111     <span class="keyword">typedef</span>         T   element_type;
00112     <span class="keyword">typedef</span>         T*  pointer;
00113     <span class="keyword">typedef</span>         T*  iterator;
00114     <span class="keyword">typedef</span>         T&amp;  reference;
00115     <span class="keyword">typedef</span> <span class="keyword">const</span>   T*  const_iterator;
00116     <span class="keyword">typedef</span> <span class="keyword">const</span>   T&amp;  const_reference;
00117 
00118     Subscript lbound()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 1;}
00119  
00120   <span class="keyword">protected</span>:
00121     Subscript m_;
00122     Subscript n_;
00123     Subscript mn_;      <span class="comment">// total size</span>
00124     T* v_;                  
00125     T** row_;           
00126     T* vm1_ ;       <span class="comment">// these point to the same data, but are 1-based </span>
00127     T** rowm1_;
00128 
00129     <span class="comment">// internal helper function to create the array</span>
00130     <span class="comment">// of row pointers</span>
00131 
00132     <span class="keywordtype">void</span> initialize(Subscript M, Subscript N)
00133     {
00134         mn_ = M*N;
00135         m_ = M;
00136         n_ = N;
00137 
00138 <span class="preprocessor">#ifdef DOLD_ALLOC</span>
00139 <span class="preprocessor"></span>        v_ = <span class="keyword">new</span> T[mn_]; 
00140         row_ = <span class="keyword">new</span> T*[M];
00141         rowm1_ = <span class="keyword">new</span> T*[M];
00142 
00143         assert(v_  != NULL);
00144         assert(row_  != NULL);
00145         assert(rowm1_ != NULL);
00146 <span class="preprocessor">#else</span>
00147 <span class="preprocessor"></span>        <span class="keywordflow">try</span>{
00148           v_ = <span class="keyword">new</span> T[mn_]; 
00149         } <span class="comment">//try</span>
00150         <span class="keywordflow">catch</span> ( bad_alloc exception ) {      
00151           cerr &lt;&lt; <span class="stringliteral">"Memory allocation failed in file cppmat.h, method initialize()."</span>
00152                &lt;&lt; <span class="stringliteral">"Exiting with value 1.\n"</span>;
00153           exit(1);
00154         } <span class="comment">//catch</span>
00155 
00156         <span class="keywordflow">try</span>{
00157           row_ = <span class="keyword">new</span> T*[M];
00158         } <span class="comment">//try</span>
00159         <span class="keywordflow">catch</span> (bad_alloc exception) {      
00160           cerr &lt;&lt; <span class="stringliteral">"Memory allocation failed in file cppmat.h, method initialize()."</span>
00161                &lt;&lt; <span class="stringliteral">"Exiting with value 1.\n"</span>;
00162           exit(1);
00163         } <span class="comment">//catch</span>
00164 
00165         <span class="keywordflow">try</span>{
00166           rowm1_ = <span class="keyword">new</span> T*[M];
00167         } <span class="comment">//try</span>
00168         <span class="keywordflow">catch</span> ( bad_alloc exception ) {      
00169           cerr &lt;&lt; <span class="stringliteral">"Memory allocation failed in file cppmat.h, method initialize()."</span>
00170                &lt;&lt; <span class="stringliteral">"Exiting with value 1.\n"</span>;
00171           exit(1);
00172         } <span class="comment">//catch</span>
00173 <span class="preprocessor">#endif</span>
00174 <span class="preprocessor"></span>
00175         T* p = v_;              
00176         vm1_ = v_ - 1;
00177         <span class="keywordflow">for</span> (Subscript i=0; i&lt;M; i++)
00178         {
00179             row_[i] = p;
00180             rowm1_[i] = p-1;
00181             p += N ;
00182             
00183         }
00184 
00185         rowm1_ -- ;     <span class="comment">// compensate for 1-based offset</span>
00186     }
00187    
00188     <span class="keywordtype">void</span> copy(<span class="keyword">const</span> T*  v)
00189     {
00190         Subscript N = m_ * n_;
00191         Subscript i;
00192 
00193 <span class="preprocessor">#ifdef TNT_UNROLL_LOOPS</span>
00194 <span class="preprocessor"></span>        Subscript Nmod4 = N &amp; 3;
00195         Subscript N4 = N - Nmod4;
00196 
00197         <span class="keywordflow">for</span> (i=0; i&lt;N4; i+=4)
00198         {
00199             v_[i] = v[i];
00200             v_[i+1] = v[i+1];
00201             v_[i+2] = v[i+2];
00202             v_[i+3] = v[i+3];
00203         }
00204 
00205         <span class="keywordflow">for</span> (i=N4; i&lt; N; i++)
00206             v_[i] = v[i];
00207 <span class="preprocessor">#else</span>
00208 <span class="preprocessor"></span>
00209         <span class="keywordflow">for</span> (i=0; i&lt; N; i++)
00210             v_[i] = v[i];
00211 <span class="preprocessor">#endif      </span>
00212 <span class="preprocessor"></span>    }
00213 
00214     <span class="keywordtype">void</span> set(<span class="keyword">const</span> T&amp; val)
00215     {
00216         Subscript N = m_ * n_;
00217         Subscript i;
00218 
00219 <span class="preprocessor">#ifdef TNT_UNROLL_LOOPS</span>
00220 <span class="preprocessor"></span>        Subscript Nmod4 = N &amp; 3;
00221         Subscript N4 = N - Nmod4;
00222 
00223         <span class="keywordflow">for</span> (i=0; i&lt;N4; i+=4)
00224         {
00225             v_[i] = val;
00226             v_[i+1] = val;
00227             v_[i+2] = val;
00228             v_[i+3] = val; 
00229         }
00230 
00231         <span class="keywordflow">for</span> (i=N4; i&lt; N; i++)
00232             v_[i] = val;
00233 <span class="preprocessor">#else</span>
00234 <span class="preprocessor"></span>
00235         <span class="keywordflow">for</span> (i=0; i&lt; N; i++)
00236             v_[i] = val;
00237         
00238 <span class="preprocessor">#endif      </span>
00239 <span class="preprocessor"></span>    }
00240     
00241 
00242     
00243     <span class="keywordtype">void</span> destroy()
00244     {     
00245         <span class="comment">/* do nothing, if no memory has been previously allocated */</span>
00246         <span class="keywordflow">if</span> (v_ == NULL) return ;
00247 
00248         <span class="comment">/* if we are here, then matrix was previously allocated */</span>
00249         <span class="keywordflow">if</span> (v_ != NULL) <span class="keyword">delete</span> [] (v_);     
00250         <span class="keywordflow">if</span> (row_ != NULL) <span class="keyword">delete</span> [] (row_);
00251 
00252         <span class="comment">/* return rowm1_ back to original value */</span>
00253         rowm1_ ++;
00254         <span class="keywordflow">if</span> (rowm1_ != NULL ) <span class="keyword">delete</span> [] (rowm1_);
00255     }
00256 
00257 
00258   <span class="keyword">public</span>:
00259 
00260     operator T**(){ <span class="keywordflow">return</span>  row_; }
00261     operator T**()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> row_; }
00262 
00263 
00264     Subscript size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mn_; }
00265 
00266     <span class="comment">// constructors</span>
00267 
00268     Matrix() : m_(0), n_(0), mn_(0), v_(0), row_(0), vm1_(0), rowm1_(0) {};
00269 
00270     Matrix(<span class="keyword">const</span> Matrix&lt;T&gt; &amp;A)
00271     {
00272         initialize(A.m_, A.n_);
00273         copy(A.v_);
00274     }
00275 
00276     Matrix(Subscript M, Subscript N, <span class="keyword">const</span> T&amp; value = T(0))
00277     {
00278         initialize(M,N);
00279         set(value);
00280     }
00281 
00282     Matrix(Subscript M, Subscript N, <span class="keyword">const</span> T* v)
00283     {
00284         initialize(M,N);
00285         copy(v);
00286     }
00287 
00288     Matrix(Subscript M, Subscript N, <span class="keywordtype">char</span> *s)
00289     {
00290         initialize(M,N);   
00291 
00292         istringstream ins(s);        
00293         Subscript i, j;
00294 
00295         <span class="keywordflow">for</span> (i=0; i&lt;M; i++)
00296             <span class="keywordflow">for</span> (j=0; j&lt;N; j++)
00297                 ins &gt;&gt; row_[i][j];
00298     }
00299 
00300     <span class="comment">// destructor</span>
00301     <span class="comment">//</span>
00302     ~Matrix()
00303     {
00304         destroy();
00305     }
00306 
00307 
00308     <span class="comment">// reallocating</span>
00309     <span class="comment">//</span>
00310     Matrix&lt;T&gt;&amp; newsize(Subscript M, Subscript N)
00311     {
00312         <span class="keywordflow">if</span> (num_rows() == M &amp;&amp; num_cols() == N)
00313             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00314 
00315         destroy();
00316         initialize(M,N);
00317         
00318         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00319     }
00320 
00321 
00322 
00323 
00324     <span class="comment">// assignments</span>
00325     <span class="comment">//</span>
00326     Matrix&lt;T&gt;&amp; operator=(<span class="keyword">const</span> Matrix&lt;T&gt; &amp;A)
00327     {
00328         <span class="keywordflow">if</span> (v_ == A.v_)
00329             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00330 
00331         <span class="keywordflow">if</span> (m_ == A.m_  &amp;&amp; n_ == A.n_)      <span class="comment">// no need to re-alloc</span>
00332             copy(A.v_);
00333 
00334         <span class="keywordflow">else</span>
00335         {
00336             destroy();
00337             initialize(A.m_, A.n_);
00338             copy(A.v_);
00339         }
00340 
00341         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00342     }
00343         
00344     Matrix&lt;T&gt;&amp; operator=(<span class="keyword">const</span> T&amp; scalar)
00345     { 
00346         set(scalar); 
00347         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00348     }
00349 
00350 
00351     Subscript dim(Subscript d)<span class="keyword"> const </span>
00352 <span class="keyword">    </span>{
00353 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00354 <span class="preprocessor"></span>       assert( d &gt;= 1);
00355         assert( d &lt;= 2);
00356 <span class="preprocessor">#endif</span>
00357 <span class="preprocessor"></span>        <span class="keywordflow">return</span> (d==1) ? m_ : ((d==2) ? n_ : 0); 
00358     }
00359 
00360     Subscript num_rows()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_; }
00361     Subscript num_cols()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> n_; }
00362 
00363 
00364   <span class="keyword">inline</span> T* operator[](Subscript i)
00365     {
00366 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00367 <span class="preprocessor"></span>        assert(0&lt;=i);
00368         assert(i &lt; m_) ;
00369 <span class="preprocessor">#endif</span>
00370 <span class="preprocessor"></span>        <span class="keywordflow">return</span> row_[i];
00371     }
00372 
00373 <span class="comment">/*START - cmsief************************/</span>
00374   
00375   <span class="comment">/*This is a Chris Siefert original that attempts to return a vector*/</span>
00376   <span class="keyword">inline</span> Vector&lt;T&gt; row (Subscript i)<span class="keyword"> const</span>
00377 <span class="keyword">    </span>{
00378 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00379 <span class="preprocessor"></span>     assert(0&lt;=i);
00380      assert(i &lt; m_) ;
00381 <span class="preprocessor">#endif</span>
00382 <span class="preprocessor"></span>     Vector&lt;T&gt;temp(n_,row_[i]);
00383      <span class="keywordflow">return</span> (temp);     
00384     }
00385 
00386   <span class="keyword">inline</span> Vector&lt;T&gt; col (Subscript i)<span class="keyword"> const</span>
00387 <span class="keyword">    </span>{
00388 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00389 <span class="preprocessor"></span>     assert(0&lt;=i);
00390      assert(i &lt; n_) ;
00391 <span class="preprocessor">#endif  </span>
00392 <span class="preprocessor"></span>     Vector&lt;T&gt;temp(m_);
00393      <span class="keywordflow">for</span>(<span class="keywordtype">long</span> f=0;f&lt;m_;f++) temp[f]=row_[f][i];
00394      <span class="keywordflow">return</span> (temp);
00395     }
00396 <span class="comment">/*END - cmsief************************/</span>
00397   
00398   <span class="keyword">inline</span> <span class="keyword">const</span> T* operator[](Subscript i)<span class="keyword"> const</span>
00399 <span class="keyword">    </span>{
00400 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00401 <span class="preprocessor"></span>      assert(0&lt;=i);
00402       assert(i &lt; m_) ;
00403 <span class="preprocessor">#endif</span>
00404 <span class="preprocessor"></span>      <span class="keywordflow">return</span> row_[i];
00405     }
00406 
00407     <span class="comment">/*  Changed all this from being 1-based to good ol' C-type</span>
00408 <span class="comment">     *  0-based indexing.</span>
00409 <span class="comment">     *     pls, 5/15/03</span>
00410 <span class="comment">     */</span>
00411 
00412   <span class="comment">// this is for a sanity check later---using an old version of this</span>
00413   <span class="comment">// file will result in off-by-1 errors and give incorrect results.</span>
00414 <span class="preprocessor">#define _changed_f_indexing_to_c_pls</span>
00415 <span class="preprocessor"></span>
00416     <span class="keyword">inline</span> reference operator()(Subscript i)
00417     { 
00418 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00419 <span class="preprocessor"></span>        assert(1&lt;=i);
00420         assert(i &lt;= mn_) ;
00421 <span class="preprocessor">#endif</span>
00422 <span class="preprocessor"></span>        <span class="comment">//return vm1_[i];</span>
00423         <span class="keywordflow">return</span> v_[i]; 
00424     }
00425 
00426     <span class="keyword">inline</span> const_reference operator()(Subscript i)<span class="keyword"> const</span>
00427 <span class="keyword">    </span>{ 
00428 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00429 <span class="preprocessor"></span>        assert(1&lt;=i);
00430         assert(i &lt;= mn_) ;
00431 <span class="preprocessor">#endif</span>
00432 <span class="preprocessor"></span>        <span class="comment">//return vm1_[i]; </span>
00433         <span class="keywordflow">return</span> v_[i]; 
00434     }
00435 
00436 
00437     <span class="keyword">inline</span> reference operator()(Subscript i, Subscript j)
00438     { 
00439 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00440 <span class="preprocessor"></span>        assert(1&lt;=i);
00441         assert(i &lt;= m_) ;
00442         assert(1&lt;=j);
00443         assert(j &lt;= n_);
00444 <span class="preprocessor">#endif</span>
00445 <span class="preprocessor"></span>        <span class="comment">//return  rowm1_[i][j]; </span>
00446         <span class="keywordflow">return</span>  row_[i][j]; 
00447     }
00448 
00449 
00450     
00451     <span class="keyword">inline</span> const_reference operator() (Subscript i, Subscript j)<span class="keyword"> const</span>
00452 <span class="keyword">    </span>{
00453 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00454 <span class="preprocessor"></span>        assert(1&lt;=i);
00455         assert(i &lt;= m_) ;
00456         assert(1&lt;=j);
00457         assert(j &lt;= n_);
00458 <span class="preprocessor">#endif</span>
00459 <span class="preprocessor"></span>        <span class="comment">//return  rowm1_[i][j]; </span>
00460         <span class="keywordflow">return</span>  row_[i][j]; 
00461     }
00462 
00463     <span class="comment">/*  end P.L. Shepherd hacks to C-ize the () operators */</span>
00464 
00465 <span class="preprocessor">#ifdef OLD_LIBC</span>
00466 <span class="preprocessor"></span>  <span class="keyword">friend</span> istream &amp; operator&gt;&gt;(istream &amp;s, Matrix&lt;T&gt; &amp;A);
00467 <span class="preprocessor">#else</span>
00468 <span class="preprocessor"></span>  <span class="comment">//  template&lt;class T&gt;</span>
00469   <span class="keyword">friend</span> istream &amp; operator&gt;&gt;&lt;&gt;(istream &amp;s, Matrix&lt;T&gt; &amp;A);
00470 <span class="preprocessor">#endif  </span>
00471 <span class="preprocessor"></span>  <span class="comment">//        friend std::istream &amp; operator&gt;&gt;(std::istream &amp;s, Matrix&lt;T&gt; &amp;A);</span>
00472 
00473 <span class="preprocessor">#ifdef TNT_USE_REGIONS</span>
00474 <span class="preprocessor"></span>
00475     <span class="keyword">typedef</span> Region2D&lt;Matrix&lt;T&gt; &gt; Region;
00476     
00477 
00478     Region operator()(<span class="keyword">const</span> Index1D &amp;I, <span class="keyword">const</span> Index1D &amp;J)
00479     {
00480         <span class="keywordflow">return</span> Region(*<span class="keyword">this</span>, I,J);
00481     }
00482 
00483 
00484     <span class="keyword">typedef</span> const_Region2D&lt; Matrix&lt;T&gt; &gt; const_Region;
00485     const_Region operator()(<span class="keyword">const</span> Index1D &amp;I, <span class="keyword">const</span> Index1D &amp;J)<span class="keyword"> const</span>
00486 <span class="keyword">    </span>{
00487         <span class="keywordflow">return</span> const_Region(*<span class="keyword">this</span>, I,J);
00488     }
00489 
00490 <span class="preprocessor">#endif</span>
00491 <span class="preprocessor"></span>
00492 
00493 };
00494 
00495 
00496 <span class="comment">/* ***************************  I/O  ********************************/</span>
00497 <span class="comment">//std::ostream&amp; operator&lt;&lt;(std::ostream &amp;s, const Matrix&lt;T&gt; &amp;A)</span>
00498 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00499 ostream&amp; operator&lt;&lt;(ostream &amp;s, const Matrix&lt;T&gt; &amp;A)
00500 {
00501     Subscript M=A.num_rows();
00502     Subscript N=A.num_cols();
00503 
00504     s &lt;&lt; M &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; N &lt;&lt; <span class="stringliteral">"\n"</span>;
00505 
00506     <span class="keywordflow">for</span> (Subscript i=0; i&lt;M; i++)
00507     {
00508         <span class="keywordflow">for</span> (Subscript j=0; j&lt;N; j++)
00509         {
00510           s &lt;&lt;setprecision(D_PRECISION)&lt;&lt; A[i][j] &lt;&lt; <span class="stringliteral">" "</span>;
00511         }
00512         s &lt;&lt; <span class="stringliteral">"\n"</span>;
00513     }
00514 
00515 
00516     <span class="keywordflow">return</span> s;
00517 }
00518 <span class="comment">//std::istream&amp; operator&gt;&gt;(std::istream &amp;s, Matrix&lt;T&gt; &amp;A)</span>
00519 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00520 istream&amp; operator&gt;&gt;(istream &amp;s, Matrix&lt;T&gt; &amp;A)
00521 {
00522 
00523     Subscript M, N;
00524 
00525     s &gt;&gt; M &gt;&gt; N;
00526 
00527     <span class="keywordflow">if</span> ( !(M == A.m_ &amp;&amp; N == A.n_) )
00528     {
00529         A.destroy();
00530         A.initialize(M,N);
00531     }
00532 
00533 
00534     <span class="keywordflow">for</span> (Subscript i=0; i&lt;M; i++)
00535         <span class="keywordflow">for</span> (Subscript j=0; j&lt;N; j++)
00536         {
00537             s &gt;&gt;  A[i][j];
00538         }
00539 
00540 
00541     <span class="keywordflow">return</span> s;
00542 }
00543 
00544 <span class="comment">// *******************[ basic matrix algorithms ]***************************</span>
00545 
00546 
00547 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00548 Matrix&lt;T&gt; operator+(<span class="keyword">const</span> Matrix&lt;T&gt; &amp;A, 
00549     <span class="keyword">const</span> Matrix&lt;T&gt; &amp;B)
00550 {
00551     Subscript M = A.num_rows();
00552     Subscript N = A.num_cols();
00553 
00554     assert(M==B.num_rows());
00555     assert(N==B.num_cols());
00556 
00557     Matrix&lt;T&gt; tmp(M,N);
00558     Subscript i,j;
00559 
00560     <span class="keywordflow">for</span> (i=0; i&lt;M; i++)
00561         <span class="keywordflow">for</span> (j=0; j&lt;N; j++)
00562             tmp[i][j] = A[i][j] + B[i][j];
00563 
00564     <span class="keywordflow">return</span> tmp;
00565 }
00566 
00567 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00568 Matrix&lt;T&gt; operator-(<span class="keyword">const</span> Matrix&lt;T&gt; &amp;A, 
00569     <span class="keyword">const</span> Matrix&lt;T&gt; &amp;B)
00570 {
00571     Subscript M = A.num_rows();
00572     Subscript N = A.num_cols();
00573 
00574     assert(M==B.num_rows());
00575     assert(N==B.num_cols());
00576 
00577     Matrix&lt;T&gt; tmp(M,N);
00578     Subscript i,j;
00579 
00580     <span class="keywordflow">for</span> (i=0; i&lt;M; i++)
00581         <span class="keywordflow">for</span> (j=0; j&lt;N; j++)
00582             tmp[i][j] = A[i][j] - B[i][j];
00583 
00584     <span class="keywordflow">return</span> tmp;
00585 }
00586 
00587 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00588 Matrix&lt;T&gt; mult_element(<span class="keyword">const</span> Matrix&lt;T&gt; &amp;A, 
00589     <span class="keyword">const</span> Matrix&lt;T&gt; &amp;B)
00590 {
00591     Subscript M = A.num_rows();
00592     Subscript N = A.num_cols();
00593 
00594     assert(M==B.num_rows());
00595     assert(N==B.num_cols());
00596 
00597     Matrix&lt;T&gt; tmp(M,N);
00598     Subscript i,j;
00599 
00600     <span class="keywordflow">for</span> (i=0; i&lt;M; i++)
00601         <span class="keywordflow">for</span> (j=0; j&lt;N; j++)
00602             tmp[i][j] = A[i][j] * B[i][j];
00603 
00604     <span class="keywordflow">return</span> tmp;
00605 }
00606 
00607 
00608 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00609 Matrix&lt;T&gt; transpose(<span class="keyword">const</span> Matrix&lt;T&gt; &amp;A)
00610 {
00611     Subscript M = A.num_rows();
00612     Subscript N = A.num_cols();
00613 
00614     Matrix&lt;T&gt; S(N,M);
00615     Subscript i, j;
00616 
00617     <span class="keywordflow">for</span> (i=0; i&lt;M; i++)
00618         <span class="keywordflow">for</span> (j=0; j&lt;N; j++)
00619             S[j][i] = A[i][j];
00620 
00621     <span class="keywordflow">return</span> S;
00622 }
00623 
00624 
00625     
00626 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00627 <span class="keyword">inline</span> Matrix&lt;T&gt; matmult(<span class="keyword">const</span> Matrix&lt;T&gt;  &amp;A, 
00628     <span class="keyword">const</span> Matrix&lt;T&gt; &amp;B)
00629 {
00630 
00631 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00632 <span class="preprocessor"></span>    assert(A.num_cols() == B.num_rows());
00633 <span class="preprocessor">#endif</span>
00634 <span class="preprocessor"></span>
00635     Subscript M = A.num_rows();
00636     Subscript N = A.num_cols();
00637     Subscript K = B.num_cols();
00638 
00639     Matrix&lt;T&gt; tmp(M,K);
00640     T sum;
00641 
00642     <span class="keywordflow">for</span> (Subscript i=0; i&lt;M; i++)
00643     <span class="keywordflow">for</span> (Subscript k=0; k&lt;K; k++)
00644     {
00645         sum = 0;
00646         <span class="keywordflow">for</span> (Subscript j=0; j&lt;N; j++)
00647             sum = sum +  A[i][j] * B[j][k];
00648 
00649         tmp[i][k] = sum; 
00650     }
00651 
00652     <span class="keywordflow">return</span> tmp;
00653 }
00654 
00655 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00656 <span class="keyword">inline</span> Matrix&lt;T&gt; operator*(<span class="keyword">const</span> Matrix&lt;T&gt;  &amp;A, 
00657     <span class="keyword">const</span> Matrix&lt;T&gt; &amp;B)
00658 {
00659   <span class="keywordflow">return</span> matmult(A,B);
00660 }
00661 
00662 <span class="comment">/*More Chris Siefert additions*/</span>
00663 
00664 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00665 <span class="keyword">inline</span> Matrix&lt;T&gt; scalmult(<span class="keyword">const</span> Matrix&lt;T&gt;  &amp;A, 
00666     <span class="keyword">const</span> T &amp;x)
00667 {
00668   Matrix&lt;T&gt; tmp=A;
00669   Subscript M = A.num_rows();
00670   Subscript N = A.num_cols();
00671 
00672   <span class="keywordflow">for</span>(Subscript i=0;i&lt;M;i++)
00673     <span class="keywordflow">for</span>(Subscript j=0;j&lt;N;j++)
00674       tmp[i][j]*=x;
00675   <span class="keywordflow">return</span> tmp;
00676 }
00677 
00678 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00679 <span class="keyword">inline</span> Matrix&lt;T&gt; operator*(<span class="keyword">const</span> Matrix&lt;T&gt;  &amp;A, 
00680     <span class="keyword">const</span> T &amp;x)
00681 {
00682   <span class="keywordflow">return</span> scalmult(A,x);
00683 }
00684 
00685 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00686 <span class="keyword">inline</span> Matrix&lt;T&gt; operator*(<span class="keyword">const</span> T &amp;x, 
00687     <span class="keyword">const</span> Matrix&lt;T&gt; &amp;A)
00688 {
00689   <span class="keywordflow">return</span> scalmult(A,x);
00690 }
00691 
00692 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00693 Vector&lt;T&gt; matmult(<span class="keyword">const</span> Vector&lt;T&gt; &amp;x, <span class="keyword">const</span> Matrix&lt;T&gt; &amp;A) {
00694   <span class="comment">/*pretends that x is a row-vector*/</span>
00695 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00696 <span class="preprocessor"></span>    assert(A.num_rows() == x.dim());
00697 <span class="preprocessor">#endif</span>
00698 <span class="preprocessor"></span>
00699     Subscript M = A.num_rows();
00700     Subscript N = A.num_cols();
00701 
00702     Vector&lt;T&gt; tmp(N);
00703     T sum;
00704 
00705     <span class="keywordflow">for</span> (Subscript i=0; i&lt;N; i++)
00706     {
00707         sum = 0;
00708         <span class="comment">//        Vector&lt;T&gt; coli=A.col(i);</span>
00709         <span class="keywordflow">for</span> (Subscript j=0; j&lt;M; j++)
00710             sum = sum +  A[j][i] * x[j];
00711 
00712         tmp[i] = sum; 
00713     }
00714 
00715     <span class="keywordflow">return</span> tmp;
00716 
00717 }<span class="comment">/*end matmult*/</span>
00718 
00719 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00720 <span class="keyword">inline</span> Vector&lt;T&gt; operator*(<span class="keyword">const</span> Vector&lt;T&gt; &amp;x, 
00721                            <span class="keyword">const</span> Matrix&lt;T&gt; &amp;A)
00722 {
00723   <span class="keywordflow">return</span> matmult(x,A);
00724 }
00725 
00726 
00727 <span class="comment">/*end Chris Siefert additions*/</span>
00728 
00729 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00730 <span class="keyword">inline</span> <span class="keywordtype">int</span> matmult(Matrix&lt;T&gt;&amp; C, <span class="keyword">const</span> Matrix&lt;T&gt;  &amp;A, 
00731     <span class="keyword">const</span> Matrix&lt;T&gt; &amp;B)
00732 {
00733 
00734     assert(A.num_cols() == B.num_rows());
00735 
00736     Subscript M = A.num_rows();
00737     Subscript N = A.num_cols();
00738     Subscript K = B.num_cols();
00739 
00740     C.newsize(M,K);
00741 
00742     T sum;
00743 
00744     <span class="keyword">const</span> T* row_i;
00745     <span class="keyword">const</span> T* col_k;
00746 
00747     <span class="keywordflow">for</span> (Subscript i=0; i&lt;M; i++)
00748     <span class="keywordflow">for</span> (Subscript k=0; k&lt;K; k++)
00749     {
00750         row_i  = &amp;(A[i][0]);
00751         col_k  = &amp;(B[0][k]);
00752         sum = 0;
00753         <span class="keywordflow">for</span> (Subscript j=0; j&lt;N; j++)
00754         {
00755             sum  += *row_i * *col_k;
00756             row_i++;
00757             col_k += K;
00758         }
00759         C[i][k] = sum; 
00760     }
00761 
00762     <span class="keywordflow">return</span> 0;
00763 }
00764 
00765 
00766 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00767 Vector&lt;T&gt; matmult(<span class="keyword">const</span> Matrix&lt;T&gt;  &amp;A, <span class="keyword">const</span> Vector&lt;T&gt; &amp;x)
00768 {
00769 
00770 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00771 <span class="preprocessor"></span>    assert(A.num_cols() == x.dim());
00772 <span class="preprocessor">#endif</span>
00773 <span class="preprocessor"></span>
00774     Subscript M = A.num_rows();
00775     Subscript N = A.num_cols();
00776 
00777     Vector&lt;T&gt; tmp(M);
00778     T sum;
00779 
00780     <span class="keywordflow">for</span> (Subscript i=0; i&lt;M; i++)
00781     {
00782         sum = 0;
00783         <span class="keyword">const</span> T* rowi = A[i];
00784         <span class="keywordflow">for</span> (Subscript j=0; j&lt;N; j++)
00785             sum = sum +  rowi[j] * x[j];
00786 
00787         tmp[i] = sum; 
00788     }
00789 
00790     <span class="keywordflow">return</span> tmp;
00791 }
00792 
00793 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00794 <span class="keyword">inline</span> Vector&lt;T&gt; operator*(<span class="keyword">const</span> Matrix&lt;T&gt;  &amp;A, <span class="keyword">const</span> Vector&lt;T&gt; &amp;x)
00795 {
00796     <span class="keywordflow">return</span> matmult(A,x);
00797 }
00798 
00799 <span class="comment">//} // namespace TNT</span>
00800 
00801 <span class="preprocessor">#endif</span>
00802 <span class="preprocessor"></span><span class="comment">// CMAT_H</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Sep 25 17:37:40 2007 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
