<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>vec.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">include</a></div>
<h1>vec.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">// Template Numerical Toolkit (TNT) for Linear Algebra</span>
00002 <span class="comment">//</span>
00003 <span class="comment">// BETA VERSION INCOMPLETE AND SUBJECT TO CHANGE</span>
00004 <span class="comment">// Please see http://math.nist.gov/tnt for updates</span>
00005 <span class="comment">//</span>
00006 <span class="comment">// R. Pozo</span>
00007 <span class="comment">// Mathematical and Computational Sciences Division</span>
00008 <span class="comment">// National Institute of Standards and Technology</span>
00009 
00010 
00011 <span class="comment">// Basic TNT  numerical vector (0-based [i] AND 1-based (i) indexing )</span>
00012 <span class="comment">//</span>
00013 
00014 <span class="comment">//Chris Siefert's modified namespace-free version - 6/8/99</span>
00015 <span class="comment">//adding l2norm capabilities.</span>
00016 <span class="comment">//made the dot product the overloaded *</span>
00017 <span class="comment">//component-based multiply is now compmult.</span>
00018 <span class="comment">//added Scalar * Vector, and Vector * Scalar</span>
00019 <span class="comment">//added overloaded == and != operators</span>
00020 
00021 <span class="comment">//COMPLETE OPERATOR LIST</span>
00022 <span class="comment">// Vector&lt;T&gt;&amp; newsize(Subscript N)</span>
00023 <span class="comment">// Vector&lt;T&gt;&amp; operator=(const Vector&lt;T&gt; &amp;A)</span>
00024 <span class="comment">// Vector&lt;T&gt;&amp; operator=(const T&amp; scalar)</span>
00025 <span class="comment">// Subscript dim() const (also size())</span>
00026 <span class="comment">// operator()</span>
00027 <span class="comment">// operator[]</span>
00028 <span class="comment">// ostream&amp; operator&lt;&lt;(ostream &amp;s, const Vector&lt;T&gt; &amp;A)</span>
00029 <span class="comment">// istream &amp; operator&gt;&gt;(istream &amp;s, Vector&lt;T&gt; &amp;A)</span>
00030 <span class="comment">// vector + vector</span>
00031 <span class="comment">// vector - vector</span>
00032 <span class="comment">// compmult(vector, vector) - componant-wise multiplication, used to be *</span>
00033 
00034 <span class="comment">// cmsief</span>
00035 <span class="comment">// friend bool operator==(const Vector&lt;T&gt;&amp;A, const Vector&lt;T&gt;&amp; B)</span>
00036 <span class="comment">// friend bool isnear(const Vector&lt;T&gt;&amp;A, const Vector&lt;T&gt;&amp; B, const T tolerance)</span>
00037 <span class="comment">// friend bool operator!=(const Vector&lt;T&gt;&amp;A, const Vector&lt;T&gt;&amp; B)</span>
00038 <span class="comment">// double l2norm()</span>
00039 <span class="comment">// double l2norm_sqr()</span>
00040 <span class="comment">// scalar * vector, vector * scalar (also scalmult)</span>
00041 <span class="comment">// vector * vector - dot product, uset to be dotprod</span>
00042 
00043 
00044 <span class="preprocessor">#ifndef VEC_H</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#define VEC_H</span>
00046 <span class="preprocessor"></span>
00047 <span class="preprocessor">#ifndef DOLD_ALLOC</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#include &lt;new&gt;</span>
00049 <span class="preprocessor">#endif</span>
00050 <span class="preprocessor"></span>
00051 <span class="comment">//#include "subscrpt.h"</span>
00052 <span class="preprocessor">#include &lt;cmath&gt;</span> <span class="comment">/*for l2norms*/</span>
00053 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00054 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
00055 <span class="preprocessor">#include &lt;cassert&gt;</span>
00056 <span class="preprocessor">#include &lt;iostream&gt;</span>
00057 <span class="preprocessor">#include &lt;sstream&gt;</span>
00058 <span class="preprocessor">#include &lt;iomanip&gt;</span>
00059 <span class="preprocessor">#include &lt;fstream&gt;</span>
00060 <span class="comment">//#include &lt;strstream.h&gt; deprecated</span>
00061 
00062 <span class="preprocessor">#define D_PRECISION 16</span>
00063 <span class="preprocessor"></span>
00064 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00065 <span class="comment">//namespace TNT</span>
00066 <span class="comment">//{</span>
00067 
00068 <span class="keyword">typedef</span> <span class="keywordtype">long</span> Subscript;
00069 
00070 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00071 <span class="keyword">class </span>Vector 
00072 {
00073 
00074 
00075   <span class="keyword">public</span>:
00076 
00077     <span class="keyword">typedef</span> Subscript   size_type;
00078     <span class="keyword">typedef</span>         T   value_type;
00079     <span class="keyword">typedef</span>         T   element_type;
00080     <span class="keyword">typedef</span>         T*  pointer;
00081     <span class="keyword">typedef</span>         T*  iterator;
00082     <span class="keyword">typedef</span>         T&amp;  reference;
00083     <span class="keyword">typedef</span> <span class="keyword">const</span>   T*  const_iterator;
00084     <span class="keyword">typedef</span> <span class="keyword">const</span>   T&amp;  const_reference;
00085 
00086     Subscript lbound()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 1;}
00087  
00088   <span class="keyword">protected</span>:
00089     T* v_;                  
00090     T* vm1_;        <span class="comment">// pointer adjustment for optimzied 1-offset indexing</span>
00091     Subscript n_;
00092 
00093     <span class="comment">// internal helper function to create the array</span>
00094     <span class="comment">// of row pointers</span>
00095 
00096     <span class="keywordtype">void</span> initialize(Subscript N)
00097     {
00098         <span class="comment">// adjust pointers so that they are 1-offset:</span>
00099         <span class="comment">// v_[] is the internal contiguous array, it is still 0-offset</span>
00100         <span class="comment">//</span>
00101         assert(v_ == NULL);
00102         
00103 <span class="preprocessor">#ifdef DOLD_ALLOC</span>
00104 <span class="preprocessor"></span>        v_ = <span class="keyword">new</span> T[N];
00105         assert(v_  != NULL);
00106 <span class="preprocessor">#else</span>
00107 <span class="preprocessor"></span>        <span class="keywordflow">try</span>{
00108           v_ = <span class="keyword">new</span> T[N];
00109         } <span class="comment">//try </span>
00110         <span class="keywordflow">catch</span> ( bad_alloc exception ) {      
00111           cerr &lt;&lt; <span class="stringliteral">"Memory allocation failed in file vec.h, method initialize()."</span>
00112                &lt;&lt; <span class="stringliteral">"Exiting with value 1.\n"</span>;
00113           exit(1);
00114         } <span class="comment">//catch</span>
00115 <span class="preprocessor">#endif</span>
00116 <span class="preprocessor"></span>        vm1_ = v_-1;
00117         n_ = N;
00118     }
00119    
00120     <span class="keywordtype">void</span> copy(<span class="keyword">const</span> T*  v)
00121     {
00122         Subscript N = n_;
00123         Subscript i;
00124 
00125 <span class="preprocessor">#ifdef TNT_UNROLL_LOOPS</span>
00126 <span class="preprocessor"></span>        Subscript Nmod4 = N &amp; 3;
00127         Subscript N4 = N - Nmod4;
00128 
00129         <span class="keywordflow">for</span> (i=0; i&lt;N4; i+=4)
00130         {
00131             v_[i] = v[i];
00132             v_[i+1] = v[i+1];
00133             v_[i+2] = v[i+2];
00134             v_[i+3] = v[i+3];
00135         }
00136 
00137         <span class="keywordflow">for</span> (i=N4; i&lt; N; i++)
00138             v_[i] = v[i];
00139 <span class="preprocessor">#else</span>
00140 <span class="preprocessor"></span>
00141         <span class="keywordflow">for</span> (i=0; i&lt; N; i++)
00142             v_[i] = v[i];
00143 <span class="preprocessor">#endif      </span>
00144 <span class="preprocessor"></span>    }
00145 
00146     <span class="keywordtype">void</span> set(<span class="keyword">const</span> T&amp; val)
00147     {
00148         Subscript N = n_;
00149         Subscript i;
00150 
00151 <span class="preprocessor">#ifdef TNT_UNROLL_LOOPS</span>
00152 <span class="preprocessor"></span>        Subscript Nmod4 = N &amp; 3;
00153         Subscript N4 = N - Nmod4;
00154 
00155         <span class="keywordflow">for</span> (i=0; i&lt;N4; i+=4)
00156         {
00157             v_[i] = val;
00158             v_[i+1] = val;
00159             v_[i+2] = val;
00160             v_[i+3] = val; 
00161         }
00162 
00163         <span class="keywordflow">for</span> (i=N4; i&lt; N; i++)
00164             v_[i] = val;
00165 <span class="preprocessor">#else</span>
00166 <span class="preprocessor"></span>
00167         <span class="keywordflow">for</span> (i=0; i&lt; N; i++)
00168             v_[i] = val;
00169         
00170 <span class="preprocessor">#endif      </span>
00171 <span class="preprocessor"></span>    }
00172     
00173 
00174 
00175     <span class="keywordtype">void</span> destroy()
00176     {     
00177         <span class="comment">/* do nothing, if no memory has been previously allocated */</span>
00178         <span class="keywordflow">if</span> (v_ == NULL) return ;
00179 
00180         <span class="comment">/* if we are here, then matrix was previously allocated */</span>
00181         <span class="keyword">delete</span> [] (v_);     
00182 
00183         v_ = NULL;
00184         vm1_ = NULL;
00185     }
00186 
00187 
00188   <span class="keyword">public</span>:
00189 
00190     <span class="comment">// access</span>
00191 
00192     iterator begin() { <span class="keywordflow">return</span> v_;}
00193     iterator end()   { <span class="keywordflow">return</span> v_ + n_; }
00194     <span class="keyword">const</span> iterator begin()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> v_;}
00195     <span class="keyword">const</span> iterator end()<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> v_ + n_; }
00196 
00197     <span class="comment">// destructor</span>
00198 
00199     ~Vector() 
00200     {
00201         destroy();
00202     }
00203 
00204     <span class="comment">// constructors</span>
00205 
00206     Vector() : v_(0), vm1_(0), n_(0)  {};
00207 
00208     Vector(<span class="keyword">const</span> Vector&lt;T&gt; &amp;A) : v_(0), vm1_(0), n_(0)
00209     {
00210         initialize(A.n_);
00211         copy(A.v_);
00212     }
00213 
00214     Vector(Subscript N, <span class="keyword">const</span> T&amp; value = T(0)) :  v_(0), vm1_(0), n_(0)
00215     {
00216         initialize(N);
00217         set(value);
00218     }
00219 
00220     Vector(Subscript N, <span class="keyword">const</span> T* v) :  v_(0), vm1_(0), n_(0)
00221     {
00222         initialize(N);
00223         copy(v);
00224     }
00225 
00226     Vector(Subscript N, <span class="keywordtype">char</span> *s) :  v_(0), vm1_(0), n_(0)
00227     {
00228         initialize(N);
00229         istringstream ins(s);     
00230 
00231         Subscript i;
00232 
00233         <span class="keywordflow">for</span> (i=0; i&lt;N; i++)
00234                 ins &gt;&gt; v_[i];
00235     }
00236 
00237 
00238     <span class="comment">// methods</span>
00239     <span class="comment">// </span>
00240     Vector&lt;T&gt;&amp; newsize(Subscript N)
00241     {
00242         <span class="keywordflow">if</span> (n_ == N) <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00243 
00244         destroy();
00245         initialize(N);
00246 
00247         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00248     }
00249 
00250   
00251     <span class="comment">// assignments</span>
00252     <span class="comment">//</span>
00253     Vector&lt;T&gt;&amp; operator=(<span class="keyword">const</span> Vector&lt;T&gt; &amp;A)
00254     {
00255         <span class="keywordflow">if</span> (v_ == A.v_)
00256             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00257 
00258         <span class="keywordflow">if</span> (n_ == A.n_)         <span class="comment">// no need to re-alloc</span>
00259             copy(A.v_);
00260 
00261         <span class="keywordflow">else</span>
00262         {
00263             destroy();
00264             initialize(A.n_);
00265             copy(A.v_);
00266         }
00267 
00268         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00269     }
00270         
00271     Vector&lt;T&gt;&amp; operator=(<span class="keyword">const</span> T&amp; scalar)
00272     { 
00273         set(scalar);  
00274         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00275     }
00276 
00277     Subscript dim()<span class="keyword"> const </span>
00278 <span class="keyword">    </span>{
00279         <span class="keywordflow">return</span>  n_; 
00280     }
00281 
00282     Subscript size()<span class="keyword"> const </span>
00283 <span class="keyword">    </span>{
00284         <span class="keywordflow">return</span>  n_; 
00285     }
00286 
00287   <span class="comment">/*Equivalence Operators -cmsief*/</span>
00288 
00289   <span class="keyword">friend</span> <span class="keywordtype">bool</span> isnear(<span class="keyword">const</span> Vector&lt;T&gt;&amp;A, <span class="keyword">const</span> Vector&lt;T&gt;&amp; B, <span class="keyword">const</span> T tolerance) {
00290     <span class="keywordtype">bool</span> s=<span class="keyword">true</span>;
00291     <span class="keywordflow">if</span>(A.n_!=B.n_ || tolerance&lt;0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00292 
00293     <span class="keywordflow">for</span>(Subscript i=0;s&amp;&amp;i&lt;A.n_;i++){
00294       <span class="keywordflow">if</span> (fabs(A.v_[i]-B.v_[i]) &gt; tolerance ) s=<span class="keyword">false</span>;
00295     }
00296     <span class="keywordflow">return</span> s;    
00297   }<span class="comment">/*end isnear*/</span>
00298     
00299   <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> Vector&lt;T&gt;&amp;A, <span class="keyword">const</span> Vector&lt;T&gt;&amp; B) {
00300     <span class="keywordtype">bool</span> s=<span class="keyword">true</span>;
00301     <span class="keywordflow">if</span>(A.n_!=B.n_) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00302 
00303     <span class="keywordflow">for</span>(Subscript i=0;s&amp;&amp;i&lt;A.n_;i++){
00304       <span class="keywordflow">if</span> (A.v_[i]!=B.v_[i]) s=<span class="keyword">false</span>;
00305     }
00306     <span class="keywordflow">return</span> s;    
00307   }
00308   
00309   <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> Vector&lt;T&gt;&amp;A, <span class="keyword">const</span> Vector&lt;T&gt;&amp; B) {
00310     <span class="keywordflow">return</span> !(A==B);
00311   }
00312     
00313   <span class="comment">/*end cmsief*/</span>
00314 
00315   
00316     <span class="keyword">inline</span> reference operator()(Subscript i)
00317     { 
00318 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00319 <span class="preprocessor"></span>        assert(1&lt;=i);
00320         assert(i &lt;= n_) ;
00321 <span class="preprocessor">#endif</span>
00322 <span class="preprocessor"></span>        <span class="keywordflow">return</span> vm1_[i]; 
00323     }
00324 
00325     <span class="keyword">inline</span> const_reference operator() (Subscript i)<span class="keyword"> const</span>
00326 <span class="keyword">    </span>{
00327 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00328 <span class="preprocessor"></span>        assert(1&lt;=i);
00329         assert(i &lt;= n_) ;
00330 <span class="preprocessor">#endif</span>
00331 <span class="preprocessor"></span>        <span class="keywordflow">return</span> vm1_[i]; 
00332     }
00333 
00334     <span class="keyword">inline</span> reference operator[](Subscript i)
00335     { 
00336 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00337 <span class="preprocessor"></span>        assert(0&lt;=i);
00338         assert(i &lt; n_) ;
00339 <span class="preprocessor">#endif</span>
00340 <span class="preprocessor"></span>        <span class="keywordflow">return</span> v_[i]; 
00341     }
00342 
00343     <span class="keyword">inline</span> const_reference operator[](Subscript i)<span class="keyword"> const</span>
00344 <span class="keyword">    </span>{
00345 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00346 <span class="preprocessor"></span>        assert(0&lt;=i);
00347         assert(i &lt; n_) ;
00348 <span class="preprocessor">#endif</span>
00349 <span class="preprocessor"></span>        <span class="keywordflow">return</span> v_[i]; 
00350     }
00351 
00352 
00353   <span class="comment">//  friend std::istream &amp; operator&gt;&gt;(std::istream &amp;s, Vector&lt;T&gt; &amp;A);</span>
00354 <span class="preprocessor">#ifdef OLD_LIBC</span>
00355 <span class="preprocessor"></span>  <span class="keyword">friend</span> istream &amp; operator&gt;&gt;(istream &amp;s, Vector&lt;T&gt; &amp;A);
00356 <span class="preprocessor">#else</span>
00357 <span class="preprocessor"></span>  <span class="comment">//  template&lt;class T&gt;</span>
00358   <span class="keyword">friend</span> istream &amp; operator&gt;&gt;&lt;&gt;(istream &amp;s, Vector&lt;T&gt; &amp;A);
00359 <span class="preprocessor">#endif</span>
00360 <span class="preprocessor"></span>  
00361 <span class="comment">// *******************[ basic norm algorithms ]***********************cmsief</span>
00362 
00363   <span class="keywordtype">double</span> l2norm() {
00364 
00365     <span class="comment">/*This algorithm is drawn from the f2c'd CLAPACK from netlib.</span>
00366 <span class="comment">      translated by f2c (version 19940927).</span>
00367 <span class="comment">      Modified on 14-October-1993 to inline the call to DLASSQ.   </span>
00368 <span class="comment">      Sven Hammarling, Nag Ltd.   </span>
00369 <span class="comment">      Modified on 25-May-1999 to act in a C++ manner and work with R. Pozo's Vector.</span>
00370 <span class="comment">      Chris Siefert, College of William and Mary.</span>
00371 <span class="comment">      This returns the l2norm of the vector.</span>
00372 <span class="comment">    */</span>
00373     
00374     <span class="keywordtype">double</span> d__1, scale, absxi, ssq;
00375     
00376     <span class="keywordflow">if</span> (n_ &lt; 1) <span class="keywordflow">return</span> (0.0);
00377     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n_ == 1) <span class="keywordflow">return</span>(fabs((<span class="keywordtype">double</span>)v_[0]));
00378     <span class="keywordflow">else</span> {
00379       scale = 0.0;
00380       ssq = 1.0;
00381       
00382       <span class="keywordflow">for</span> (Subscript ix = 0; ix &lt; n_; ix++ ) {        
00383         <span class="keywordflow">if</span> (v_[ix] != 0.0) {          
00384           absxi = (d__1 = (double) v_[ix], fabs(d__1));            
00385           <span class="keywordflow">if</span> (scale &lt; absxi) {
00386             <span class="comment">/* Computing 2nd power */</span>
00387             d__1 = scale / absxi;
00388             ssq = ssq * (d__1 * d__1) + 1.0;
00389             scale = absxi;
00390           }<span class="comment">/*end if*/</span>
00391           <span class="keywordflow">else</span> {
00392             <span class="comment">/* Computing 2nd power */</span>
00393             d__1 = absxi / scale;
00394             ssq += d__1 * d__1;
00395           }<span class="comment">/*end else*/</span>
00396         }<span class="comment">/*end if*/</span>
00397         <span class="comment">/* L10: */</span>
00398       }<span class="comment">/*end for*/</span>
00399       <span class="keywordflow">return</span>(scale * sqrt(ssq));
00400     }<span class="comment">/*end else*/</span>
00401   }<span class="comment">/*end l2norm - cmsief*/</span>
00402 
00403 
00404   <span class="keywordtype">double</span> l2norm_sqr() {
00405     
00406     <span class="comment">/*This algorithm is drawn from the f2c'd CLAPACK from netlib.</span>
00407 <span class="comment">      translated by f2c (version 19940927).</span>
00408 <span class="comment">      Modified on 14-October-1993 to inline the call to DLASSQ.   </span>
00409 <span class="comment">      Sven Hammarling, Nag Ltd.   </span>
00410 <span class="comment">      Modified on 25-May-1999 to act in a C++ manner and work with R. Pozo's Vector.</span>
00411 <span class="comment">      Chris Siefert, College of William and Mary.</span>
00412 <span class="comment">      This returns the square of the l2norm.</span>
00413 <span class="comment">    */</span>
00414     
00415     <span class="keywordtype">double</span> d__1, scale, absxi, ssq;
00416     
00417     <span class="keywordflow">if</span> (n_ &lt; 1) <span class="keywordflow">return</span> (0.0);
00418     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n_ == 1) <span class="keywordflow">return</span>(fabs((<span class="keywordtype">double</span>)v_[0]*v_[0]));
00419     <span class="keywordflow">else</span> {
00420       scale = 0.0;
00421       ssq = 1.0;
00422       
00423       <span class="keywordflow">for</span> (Subscript ix = 0; ix &lt; n_; ix++ ) {        
00424         <span class="keywordflow">if</span> (v_[ix] != 0.0) {          
00425           absxi = (d__1 = (double) v_[ix], fabs(d__1));            
00426           <span class="keywordflow">if</span> (scale &lt; absxi) {
00427             <span class="comment">/* Computing 2nd power */</span>
00428             d__1 = scale / absxi;
00429             ssq = ssq * (d__1 * d__1) + 1.0;
00430             scale = absxi;
00431           }<span class="comment">/*end if*/</span>
00432           <span class="keywordflow">else</span> {
00433             <span class="comment">/* Computing 2nd power */</span>
00434             d__1 = absxi / scale;
00435             ssq += d__1 * d__1;
00436           }<span class="comment">/*end else*/</span>
00437         }<span class="comment">/*end if*/</span>
00438         <span class="comment">/* L10: */</span>
00439       }<span class="comment">/*end for*/</span>
00440       <span class="keywordflow">return</span>(scale * scale * ssq);
00441     }<span class="comment">/*end else*/</span>
00442   }<span class="comment">/*end l2norm_sqr - cmsief*/</span>
00443   
00444 };<span class="comment">/*end class*/</span>
00445 
00446 
00447 <span class="comment">/* ***************************  I/O  ********************************/</span>
00448 <span class="comment">//std::ostream&amp; operator&lt;&lt;(std::ostream &amp;s, const Vector&lt;T&gt; &amp;A)</span>
00449 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00450 ostream&amp; operator&lt;&lt;(ostream &amp;s, const Vector&lt;T&gt; &amp;A)
00451 {
00452     Subscript N=A.dim();
00453 
00454     s &lt;&lt;  N &lt;&lt; endl;
00455 
00456     <span class="keywordflow">for</span> (Subscript i=0; i&lt;N; i++)
00457       s  &lt;&lt;setprecision(D_PRECISION) &lt;&lt; A[i] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; endl;
00458     s &lt;&lt; endl;
00459 
00460     <span class="keywordflow">return</span> s;
00461 }
00462 <span class="comment">//std::istream &amp; operator&gt;&gt;(std::istream &amp;s, Vector&lt;T&gt; &amp;A)</span>
00463 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00464 istream &amp; operator&gt;&gt;(istream &amp;s, Vector&lt;T&gt; &amp;A)
00465 {
00466 
00467     Subscript N;
00468 
00469     s &gt;&gt; N;
00470 
00471     <span class="keywordflow">if</span> ( !(N == A.n_) )
00472     {
00473         A.destroy();
00474         A.initialize(N);
00475     }
00476 
00477 
00478     <span class="keywordflow">for</span> (Subscript i=0; i&lt;N; i++)
00479             s &gt;&gt;  A[i];
00480 
00481 
00482     <span class="keywordflow">return</span> s;
00483 }
00484 
00485 
00486 <span class="comment">// *******************[ basic matrix algorithms ]***************************</span>
00487 
00488 <span class="comment">/****cmsief****/</span>
00489 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00490 Vector&lt;T&gt; scalmult(<span class="keyword">const</span> Vector&lt;T&gt; &amp;A, <span class="keyword">const</span> T &amp;B)
00491 {
00492     Subscript N = A.dim(); 
00493     Vector&lt;T&gt; tmp(N);
00494     Subscript i;
00495     <span class="keywordflow">for</span> (i=0; i&lt;N; i++)
00496             tmp[i] = A[i] *B;
00497     <span class="keywordflow">return</span> tmp; 
00498 } 
00499 
00500 
00501 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00502 Vector&lt;T&gt; operator*(<span class="keyword">const</span> Vector&lt;T&gt; &amp;A, <span class="keyword">const</span> T &amp;B)
00503 {
00504   <span class="keywordflow">return</span> scalmult(A,B);
00505 }
00506 
00507 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00508 Vector&lt;T&gt; operator*(<span class="keyword">const</span> T &amp;B, <span class="keyword">const</span> Vector&lt;T&gt; &amp;A)
00509 {
00510   <span class="keywordflow">return</span> scalmult(A,B);
00511 }
00512 
00513 <span class="comment">/****end cmsief*****/</span>
00514 
00515 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00516 Vector&lt;T&gt; operator+(<span class="keyword">const</span> Vector&lt;T&gt; &amp;A, 
00517     <span class="keyword">const</span> Vector&lt;T&gt; &amp;B)
00518 {
00519     Subscript N = A.dim();
00520 
00521     assert(N==B.dim());
00522 
00523     Vector&lt;T&gt; tmp(N);
00524     Subscript i;
00525 
00526     <span class="keywordflow">for</span> (i=0; i&lt;N; i++)
00527             tmp[i] = A[i] + B[i];
00528 
00529     <span class="keywordflow">return</span> tmp;
00530 }
00531 
00532 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00533 Vector&lt;T&gt; operator-(<span class="keyword">const</span> Vector&lt;T&gt; &amp;A, 
00534     <span class="keyword">const</span> Vector&lt;T&gt; &amp;B)
00535 {
00536     Subscript N = A.dim();
00537 
00538     assert(N==B.dim());
00539 
00540     Vector&lt;T&gt; tmp(N);
00541     Subscript i;
00542 
00543     <span class="keywordflow">for</span> (i=0; i&lt;N; i++)
00544             tmp[i] = A[i] - B[i];
00545 
00546     <span class="keywordflow">return</span> tmp;
00547 }
00548 
00549 <span class="comment">//Vector&lt;T&gt; operator*(const Vector&lt;T&gt; &amp;A, const Vector&lt;T&gt; &amp;B)</span>
00550 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00551 Vector&lt;T&gt; compmult(<span class="keyword">const</span> Vector&lt;T&gt; &amp;A, <span class="keyword">const</span> Vector&lt;T&gt; &amp;B)
00552 {
00553     Subscript N = A.dim();
00554 
00555     assert(N==B.dim());
00556 
00557     Vector&lt;T&gt; tmp(N);
00558     Subscript i;
00559 
00560     <span class="keywordflow">for</span> (i=0; i&lt;N; i++)
00561             tmp[i] = A[i] * B[i];
00562 
00563     <span class="keywordflow">return</span> tmp;
00564 }
00565 
00566 <span class="comment">//T dot_prod(const Vector&lt;T&gt; &amp;A, const Vector&lt;T&gt; &amp;B)</span>
00567 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00568 T operator* (<span class="keyword">const</span> Vector&lt;T&gt; &amp;A, <span class="keyword">const</span> Vector&lt;T&gt; &amp;B)
00569 {
00570     Subscript N = A.dim();
00571     assert(N == B.dim());
00572 
00573     Subscript i;
00574     T sum = 0;
00575 
00576     <span class="keywordflow">for</span> (i=0; i&lt;N; i++)
00577         sum += A[i] * B[i];
00578 
00579     <span class="keywordflow">return</span> sum;
00580 }
00581 
00582 <span class="comment">//}   /* namespace TNT */</span>
00583 
00584 <span class="preprocessor">#endif</span>
00585 <span class="preprocessor"></span><span class="comment">// VEC_H</span>
00586 
00587 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Sep 25 17:37:40 2007 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
