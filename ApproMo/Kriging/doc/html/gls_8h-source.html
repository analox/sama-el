<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gls.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">include</a></div>
<h1>gls.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/* gls.h  </span>
00002 <span class="comment"></span>
00003 <span class="comment">   This is the header file for the generalized linear least squares class,</span>
00004 <span class="comment">   that will be used to implement a quadratic trend in the MAPS algorithm.</span>
00005 <span class="comment"></span>
00006 <span class="comment">   Currently just estimates a quadratic trend, solving the problem</span>
00007 <span class="comment"></span>
00008 <span class="comment">   y = X*beta + e</span>
00009 <span class="comment"></span>
00010 <span class="comment">   to minimize e.  We choose inner product &lt;u,v&gt; = u Sigma^{-1} v, with Sigma = sigma^{2} I.</span>
00011 <span class="comment"></span>
00012 <span class="comment">   The solution is then \hat{beta} = ( X^{T} X )^{-1} X^{T} y.</span>
00013 <span class="comment"></span>
00014 <span class="comment"></span>
00015 <span class="comment">   Anthony Padula  6/10/2000</span>
00016 <span class="comment">*/</span>
00017 
00018 <span class="preprocessor">#ifndef GLS_H</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#define GLS_H</span>
00020 <span class="preprocessor"></span>
00021 <span class="preprocessor">#include "approx.h"</span>
00022 <span class="preprocessor">#include "gamma.h"</span>
00023 <span class="preprocessor">#include "krig.h"</span>
00024 <span class="preprocessor">#include &lt;cmath&gt;</span>
00025 
00026 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00027 
00028 <span class="keyword">const</span> <span class="keywordtype">int</span> DISPLAYG = 1; <span class="comment">// Sets the amount of output</span>
00029 <span class="comment">// 0 - dead silent</span>
00030 <span class="comment">// 1 - nothing but error messages</span>
00031 <span class="comment">// 2 - also outputs estimates of mu, theta, and tolerance</span>
00032 <span class="comment">// 4 - also LOTS of messages updating it's current position</span>
00033 <span class="comment">// 5 - also outputs most important matrices.  BE WARNED: Matrices are often HUGE</span>
00034 
00035 
00036 <span class="keyword">class </span>glsapprox: <span class="keyword">public</span> approx {
00037 <span class="keyword">public</span>:
00038   glsapprox(); 
00039   glsapprox( glsapprox&amp; ToBeCopied );
00040   glsapprox( Matrix&lt;double&gt;&amp; Points,  <span class="comment">// The n x p matrix of points, one point to a row</span>
00041               Vector&lt;double&gt;&amp; Values);  <span class="comment">// The vector of function values, so</span>
00042                                        <span class="comment">// f(Points[i])=Values[i]  </span>
00043 
00044   glsapprox(  Matrix&lt;double&gt;&amp; Points, <span class="comment">// The n x p matrix of points, one point to a row</span>
00045               Vector&lt;double&gt;&amp; Values, <span class="comment">// The vector of function</span>
00046                                       <span class="comment">// values, so f(Points[i])=Values[i]</span>
00047               Matrix&lt;double&gt;&amp; InvCorr); <span class="comment">// The inverse of the correlation matrix </span>
00048 
00049   <span class="keyword">virtual</span> ~glsapprox(); <span class="comment">// Destructor</span>
00050 
00051   <span class="comment">// evalf returns the value of the function at the point passed in </span>
00052   <span class="comment">// point is a p-dim vector at which f is to be evaluated</span>
00053   <span class="keyword">virtual</span> <span class="keywordtype">double</span> evalf(<span class="keyword">const</span> Vector&lt;double&gt;&amp; point);
00054 
00055 
00056   <span class="comment">// evalderiv returns the vector value of the gradient at the point</span>
00057   <span class="keyword">virtual</span> Vector&lt;double&gt; * evalderiv( <span class="keyword">const</span> Vector&lt;double&gt; &amp; point);
00058 
00059   <span class="comment">/* virtual int setvalues();  </span>
00060 <span class="comment"></span>
00061 <span class="comment">     This is an I/O function to interactively set the necessary parameters</span>
00062 <span class="comment">     The data will be read in the format:</span>
00063 <span class="comment">     p = long integer  // the dimension of the space</span>
00064 <span class="comment">     n = long integer  // the number of points to be interpolated</span>
00065 <span class="comment">     Points = a matrix of n x p+1 doubles, such that each row is one point follwed</span>
00066 <span class="comment">       by the function value at that point.  For example, if f( (2.3, 4.5) ) = 8.2,</span>
00067 <span class="comment">       then you would input:</span>
00068 <span class="comment">       2.3 4.5 8.2</span>
00069 <span class="comment"></span>
00070 <span class="comment">     This is the same format used by reportsample() and scanfunction()</span>
00071 <span class="comment">  */</span>
00072   <span class="keyword">virtual</span> <span class="keywordtype">int</span> setvalues();  
00073 
00074   
00075   <span class="comment">/* virtual int setvalues(char* filename);</span>
00076 <span class="comment"></span>
00077 <span class="comment">     Reads the parameter values in order from a file and runs approximate() to</span>
00078 <span class="comment">     build the approximation</span>
00079 <span class="comment">     Returns 1 if successful, and 0 if insufficient data in the file.</span>
00080 <span class="comment">     Format is the same as the above.</span>
00081 <span class="comment">     Ex.</span>
00082 <span class="comment">     2</span>
00083 <span class="comment">     5</span>
00084 <span class="comment">     1.5 1.7 20.6</span>
00085 <span class="comment">     0.3 2.6 563.7</span>
00086 <span class="comment">     3.6 2.9 27.04</span>
00087 <span class="comment">     1.0 0.0 100.3</span>
00088 <span class="comment">     3.87 4.96 0.06</span>
00089 <span class="comment">  */</span>
00090   <span class="keyword">virtual</span> <span class="keywordtype">int</span> setvalues(<span class="keywordtype">char</span>* filename);
00091   
00092 
00093   <span class="comment">/* </span>
00094 <span class="comment">     This function works like the special constructor, allowing the data to be</span>
00095 <span class="comment">     passed in as parameters instead of being read from I/O.</span>
00096 <span class="comment">     Stores all data and calls approximate() to create the approximation</span>
00097 <span class="comment">  */</span>
00098   <span class="keyword">virtual</span> <span class="keywordtype">int</span> setvalues(  Matrix&lt;double&gt;&amp; Points, <span class="comment">// The n x p matrix of points, one point to a row</span>
00099                           Vector&lt;double&gt;&amp; Values);<span class="comment">// The vector of function</span>
00100                                                    <span class="comment">// values, so f(Points[i])=Values[i]</span>
00101 
00102   <span class="keyword">virtual</span> <span class="keywordtype">int</span> setvalues(  Matrix&lt;double&gt;&amp; Points, <span class="comment">// The n x p matrix of points, one point to a row</span>
00103                           Vector&lt;double&gt;&amp; Values, <span class="comment">// The vector of function</span>
00104                                                    <span class="comment">// values, so f(Points[i])=Values[i]</span>
00105                           Matrix&lt;double&gt;&amp; InvCorr); <span class="comment">// The inverse of the correlation matrix </span>
00106 
00107 
00108   <span class="comment">// Pass in the appropriate correlation matrix R so that </span>
00109   <span class="comment">// &lt;u,v&gt; = u^{T} R^{-1} v  </span>
00110   <span class="comment">// is the inner product used</span>
00111   <span class="keyword">virtual</span> <span class="keywordtype">int</span> setInverseCorrelation( Matrix&lt;double&gt;&amp; InvCorr );
00112 
00113 
00114   <span class="comment">// functions to get copies of the data members</span>
00115   
00116   <span class="comment">// Note that this returns pointer to an object which must be</span>
00117   <span class="comment">// deleted by user to avoid memory leak.</span>
00118   Vector&lt;double&gt; getbeta(); 
00119     
00120   <span class="comment">// Returns the vector of residuals e = y - X*beta </span>
00121   Vector&lt;double&gt; getresiduals();
00122 
00123   <span class="keywordtype">long</span> getk();
00124 
00125   <span class="comment">/****</span>
00126 <span class="comment">     Prints the data of the approximation to the output stream in the same format as it</span>
00127 <span class="comment">     would be read in from a file.  Thus, this function is appropriate for</span>
00128 <span class="comment">     storing functions so that they might be re-created later.</span>
00129 <span class="comment">  ****/</span>
00130   <span class="keywordtype">void</span> storeApprox( ostream&amp; outf );
00131 
00132   
00133 <span class="keyword">protected</span>:
00134 
00135   <span class="comment">// deallocates any dynamically allocated members and sets</span>
00136   <span class="comment">// them to NULL</span>
00137   <span class="keywordtype">void</span> deleteall(); 
00138   
00139   <span class="comment">// creates the approximation using the current values</span>
00140   <span class="comment">// Returns TRUE if Successful, FALSE otherwise.</span>
00141   <span class="keywordtype">int</span> approximate(); 
00142 
00143   Vector&lt;double&gt; beta;  <span class="comment">// used by evalf</span>
00144   Matrix&lt;double&gt;* Rinv;
00145  
00146   <span class="comment">// p, n, X, and y inherited from approx</span>
00147 
00148   <span class="keywordtype">long</span> k;   <span class="comment">// k = 1 + p + p*(p+1)/2</span>
00149 }; <span class="comment">// end class glsapprox</span>
00150 
00151 
00152 <span class="keyword">class </span>krigapproxWithGLS: <span class="keyword">public</span> krigapprox {
00153  <span class="keyword">public</span>:
00154   ~krigapproxWithGLS(){ deleteall(); }
00155 
00156   <span class="comment">// Uses the new gls trend</span>
00157   <span class="keyword">virtual</span> <span class="keywordtype">double</span> trend( <span class="keyword">const</span> Vector&lt;double&gt; &amp; point);
00158 
00159   <span class="comment">// The derivative of the GLS trend</span>
00160   <span class="keyword">virtual</span> Vector&lt;double&gt; * derivtrend( <span class="keyword">const</span> Vector&lt;double&gt;&amp; point);
00161 
00162  <span class="keyword">protected</span>:
00163   <span class="comment">// creates the approximation using the current values</span>
00164   <span class="comment">// Will estimate theta if necessary</span>
00165   <span class="comment">// Returns TRUE if Successful, FALSE otherwise.</span>
00166   <span class="keyword">virtual</span> <span class="keywordtype">int</span> approximate(); 
00167 
00168   glsapprox GLStrend;
00169 }; <span class="comment">// end class krigapproxWithGLS</span>
00170 <span class="preprocessor">#endif</span>
00171 <span class="preprocessor"></span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Sep 25 17:37:40 2007 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
