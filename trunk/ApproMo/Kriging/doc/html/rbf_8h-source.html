<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>rbf.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">include</a></div>
<h1>rbf.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/* rbf.h</span>
00002 <span class="comment">written by Anthony Padula       adpadu@maila.wm.edu</span>
00003 <span class="comment">This file contains the class definition for a radial basis</span>
00004 <span class="comment">function approximator.  When given a matrix of points and a vector of the</span>
00005 <span class="comment">function values at those points, will create a radial basis function</span>
00006 <span class="comment">approximation which can then be evaluated.</span>
00007 <span class="comment">This procedure is based on equations from a number of references.</span>
00008 <span class="comment">*/</span>
00009 
00010 <span class="comment">/* Instructions</span>
00011 <span class="comment">   1. create a rbfapprox object with the statement:</span>
00012 <span class="comment">        rbfapprox TestRBF;</span>
00013 <span class="comment">   </span>
00014 <span class="comment">   2. run setvalues one of three ways:</span>
00015 <span class="comment">     a. TestRBF.setvalues() will prompt the user for the necessary information.</span>
00016 <span class="comment">     However, this is only recommended for beginning users with small problems.</span>
00017 <span class="comment">     </span>
00018 <span class="comment">     b. TestRBF.setvalues( filename ) will read in the same information as (a.) from the</span>
00019 <span class="comment">     file.  This is much quicker and is recommended for most problems.</span>
00020 <span class="comment"></span>
00021 <span class="comment">     c. TestRBF.setvalues( Points, Values, deg, choice, c, beta) takes the</span>
00022 <span class="comment">     necessary info as parameters.  This is useful if you have created the</span>
00023 <span class="comment">     information at runtime.  See the function description below for details on</span>
00024 <span class="comment">     the parameters.</span>
00025 <span class="comment"></span>
00026 <span class="comment">   3. evaluate the function as often as desired.  This is done using:</span>
00027 <span class="comment">        TestRBF.evalf( x);</span>
00028 <span class="comment">      where x is a Vector&lt;double&gt; of length p which contains the point at which</span>
00029 <span class="comment">      to evaluate.</span>
00030 <span class="comment">      </span>
00031 <span class="comment">     Last Modified 7/21/99</span>
00032 <span class="comment">*/</span>
00033 <span class="preprocessor">#ifndef RBF_H</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#define RBF_H</span>
00035 <span class="preprocessor"></span>
00036 <span class="preprocessor">#include "approx.h"</span>
00037 <span class="preprocessor">#include "gamma.h"</span>
00038 
00039 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00040 
00041 <span class="keyword">const</span> <span class="keywordtype">int</span> DISPLAY = 0;  <span class="comment">// DISPLAY controls to amount of output</span>
00042 <span class="comment">// =0   Only print error messages and prompts for data</span>
00043 <span class="comment">// =1   Displays b and a as well</span>
00044 <span class="comment">// =2   Displays right-A*x, the residual vector as well</span>
00045 
00046 <span class="keyword">class </span>rbfapprox: <span class="keyword">public</span> approx {
00047 <span class="keyword">public</span>:
00048   rbfapprox(); 
00049   rbfapprox( rbfapprox&amp; ToBeCopied );
00050   rbfapprox( Matrix&lt;double&gt;&amp; Points,  <span class="comment">// The n x p matrix of points, one point to a row</span>
00051              Vector&lt;double&gt;&amp; Values,  <span class="comment">// The vector of function values, so</span>
00052                                       <span class="comment">// f(Points[i])=Values[i]</span>
00053              <span class="keywordtype">long</span> deg,    <span class="comment">// The size of the polynomial basis</span>
00054              <span class="comment">// deg &lt; 0  no polynomial basis</span>
00055              <span class="comment">// deg = 0  constant 1 only</span>
00056              <span class="comment">// 0&lt;deg&lt;=p use the first deg monomials and a constant 1 </span>
00057              <span class="keywordtype">int</span> choice, <span class="comment">// The flag for which RBF to use (see chooseRBF() below)</span>
00058              <span class="keywordtype">double</span> c,   <span class="comment">// c and beta are the parameters for the RBF </span>
00059              <span class="keywordtype">double</span> beta ); <span class="comment">// You may not need both for all choices, but always</span>
00060                             <span class="comment">// pass in something at least</span>
00061   
00062   ~rbfapprox(); <span class="comment">// Destructor</span>
00063 
00064   <span class="comment">// evalf returns the value of the function at the point passed in </span>
00065   <span class="keywordtype">double</span> evalf(<span class="keyword">const</span> Vector&lt;double&gt;&amp; point);
00066   <span class="comment">// point is a p-dim vector at which f is to be evaluated</span>
00067   
00068   <span class="keywordtype">int</span> setvalues();  <span class="comment">// This is an I/O function to interactively set the</span>
00069                              <span class="comment">// necessary parameters</span>
00070    <span class="comment">/* The data will be read in the format:</span>
00071 <span class="comment">   p = long integer  // the dimension of the space</span>
00072 <span class="comment">   n = long integer  // the number of points to be interpolated</span>
00073 <span class="comment">   degree = long     // The size of the polynomial basis</span>
00074 <span class="comment">                     // deg &lt; 0  no polynomial basis</span>
00075 <span class="comment">                     // deg = 0  constant 1 only</span>
00076 <span class="comment">                     // 0&lt;deg&lt;=p use the first deg monomials and a constant 1 </span>
00077 <span class="comment">   choice = integer  // the choice of radial basis function (see chooseRBF() below)</span>
00078 <span class="comment">   c = double        // Will only prompt for c and/or beta if needed</span>
00079 <span class="comment">   beta = double</span>
00080 <span class="comment">   Points = a matrix of n x p+1 doubles, such that each row is one point follwed</span>
00081 <span class="comment">   by the function value at that point.  For example, if f( (2.3, 4.5) ) = 8.2,</span>
00082 <span class="comment">   then you would input:</span>
00083 <span class="comment">   2.3 4.5 8.2</span>
00084 <span class="comment">   This is the same format used by reportsample() and scanfunction() below</span>
00085 <span class="comment">   */</span>
00086 
00087   <span class="keywordtype">int</span> setvalues(<span class="keywordtype">char</span>* filename);
00088    <span class="comment">/* Reads the parameter values in order from a file and runs approximate() to</span>
00089 <span class="comment">      build the approximation</span>
00090 <span class="comment">      Returns 1 if successful, and 0 if insufficient data in the file.</span>
00091 <span class="comment">      Format is the same as the above.</span>
00092 <span class="comment">      Ex.</span>
00093 <span class="comment">      2</span>
00094 <span class="comment">      5</span>
00095 <span class="comment">      -1</span>
00096 <span class="comment">      3</span>
00097 <span class="comment">      1.0</span>
00098 <span class="comment">      -1.0</span>
00099 <span class="comment">      1.5 1.7 20.6</span>
00100 <span class="comment">      0.3 2.6 563.7</span>
00101 <span class="comment">      3.6 2.9 27.04</span>
00102 <span class="comment">      1.0 0.0 100.3</span>
00103 <span class="comment">      3.87 4.96 0.06</span>
00104 <span class="comment"></span>
00105 <span class="comment">      NOTE:  Will only read in c and/or beta if necessary, depending on the</span>
00106 <span class="comment">      choice of basis function.</span>
00107 <span class="comment">   */</span>
00108 
00109   <span class="keywordtype">int</span> setvalues(  Matrix&lt;double&gt;&amp; Points, <span class="comment">// The n x p matrix of points, one point to a row</span>
00110                           Vector&lt;double&gt;&amp; Values,  <span class="comment">// The vector of function</span>
00111                                                    <span class="comment">// values, so f(Points[i])=Values[i]</span>
00112                           <span class="keywordtype">long</span> deg,  <span class="comment">// The size of the polynomial basis</span>
00113                           <span class="comment">// deg &lt; 0  no polynomial basis</span>
00114                           <span class="comment">// deg = 0  constant 1 only</span>
00115                           <span class="comment">// 0&lt;deg&lt;=p use the first deg monomials and a constant 1 </span>
00116                           <span class="keywordtype">int</span> choice, <span class="comment">// The flag for which RBF to use (see chooseRBF() below)</span>
00117                           <span class="keywordtype">double</span> c,   <span class="comment">// c and beta are the parameters for the RBF </span>
00118                           <span class="keywordtype">double</span> beta ); <span class="comment">// You may not need both for all choices, but always</span>
00119                                          <span class="comment">// pass in something at least           </span>
00120   <span class="comment">/* This function works like the special constructor, allowing the data to be</span>
00121 <span class="comment">     passed in as parameters instead of being read from I/O.</span>
00122 <span class="comment">     Stores all data and calls approximate() to create the approximation</span>
00123 <span class="comment">  */</span>
00124   <span class="keywordtype">void</span> chooseRBF( <span class="keywordtype">int</span> choice, <span class="keywordtype">double</span> c, <span class="keywordtype">double</span> beta, <span class="keywordtype">long</span> deg );
00125   <span class="comment">/*  Allows the user to choose among the possible families of radial basis</span>
00126 <span class="comment">      functions.  If the user desires a basis function not available as</span>
00127 <span class="comment">      one of the choices, then use of the chooseRBF()</span>
00128 <span class="comment">      function below is recommended.</span>
00129 <span class="comment"></span>
00130 <span class="comment">      Currently, the options are:</span>
00131 <span class="comment"></span>
00132 <span class="comment">      0  =&gt;  User specified function (See below)</span>
00133 <span class="comment"></span>
00134 <span class="comment">      1 =&gt; Thin-plate splines:  g(r) = r^beta                 beta&gt;0 and beta not even</span>
00135 <span class="comment"></span>
00136 <span class="comment">      2 =&gt; Gaussian:            g(r) = exp(-c*(r^2))          c&gt;0</span>
00137 <span class="comment"></span>
00138 <span class="comment">      3 =&gt; Multiquadrics        g(r) = (c^2 + r^2)^(beta/2)   beta&gt;-d and beta not even,</span>
00139 <span class="comment">                                                           d &gt; beta/2 </span>
00140 <span class="comment"></span>
00141 <span class="comment">      4 =&gt; Thin-plate splines   g(r) = (-1)^(beta/2+1)*r^(beta)*log(r)    beta even</span>
00142 <span class="comment"></span>
00143 <span class="comment">      5 =&gt; Sobolew splines      g(r) = (2*PI^(c))*K(nu,2*PI*r)*(r^nu)/gamma(c)</span>
00144 <span class="comment">                                       nu = c-d/2, c &gt; d/2</span>
00145 <span class="comment"></span>
00146 <span class="comment">      6 =&gt; Thin-plate splines   g(r) = (cr)^2 * log(cr)        reference suggests c=1</span>
00147 <span class="comment"></span>
00148 <span class="comment">      7 =&gt; Madych &amp; Nelson II pg 221 g(r) = -2*sqrt(pi*(1+r^2))</span>
00149 <span class="comment">     </span>
00150 <span class="comment"></span>
00151 <span class="comment">      where K_{nu}(x) is the degree nu modified Bessel function of the third order. </span>
00152 <span class="comment"></span>
00153 <span class="comment">      This function automatically constructs the new approximation.</span>
00154 <span class="comment">      setvalues() must have been run prior to using chooseRBF().</span>
00155 <span class="comment">  */</span>
00156   
00157   <span class="keywordtype">void</span> chooseRBF( <span class="keywordtype">void</span> (*RBFtoUse)(<span class="keywordtype">double</span> r, <span class="keywordtype">double</span>&amp; <span class="comment">/*output*/</span> result ), <span class="keywordtype">long</span> deg );
00158     <span class="comment">/*This is an alternative to the previous function.  It allows the user to</span>
00159 <span class="comment">      pass in a correlation function of their own.  The RBF must accept the</span>
00160 <span class="comment">      double r = ||u-v||, and return the value of the RBF using the second</span>
00161 <span class="comment">      parameter.</span>
00162 <span class="comment"></span>
00163 <span class="comment">      This sets the choice to option 0, and choosing another choice later will</span>
00164 <span class="comment">      use a different correlation function without overwriting the pointer.</span>
00165 <span class="comment">      Thus, you may switch back and forth between a hard-wired function and a</span>
00166 <span class="comment">      user specified function by indicating a new choice as directed above.</span>
00167 <span class="comment"></span>
00168 <span class="comment">      NOTE: NOT EVERY ARITHMETIC FUNCTION WORKS AS A RADIAL BASIS FUNCTION</span>
00169 <span class="comment">      Be sure to choose deg appropriately for your function.  If you are unsure,</span>
00170 <span class="comment">      use deg = p to be safe.</span>
00171 <span class="comment">    */</span> 
00172     
00173   <span class="comment">// functions to get copies of the data members</span>
00174 
00175   <span class="keywordtype">double</span> getc();
00176   <span class="keywordtype">double</span> getbeta();
00177 
00178   <span class="keywordtype">void</span> storeApprox( ostream&amp; outf );
00179 <span class="comment">/****</span>
00180 <span class="comment">     r</span>
00181 <span class="comment">     Prints the data of the rbf to the output stream in the same format as it</span>
00182 <span class="comment">     would be read in from a file.  Thus, this function is appropriate for</span>
00183 <span class="comment">     storing RBF's so that they might be re-created later.</span>
00184 <span class="comment">****/</span>
00185   
00186 <span class="keyword">protected</span>:
00187 
00188   <span class="keywordtype">void</span> deleteall(){} <span class="comment">// no dynamic variables to be deleted</span>
00189   <span class="keywordtype">int</span> approximate();  <span class="comment">// creates the approximation using the current values</span>
00190   <span class="comment">// Returns TRUE if Successful, FALSE otherwise.</span>
00191   
00192   <span class="keywordtype">double</span> polybasis( Vector&lt;double&gt; x, <span class="keywordtype">long</span> k);
00193   <span class="keywordtype">double</span> rbfvalue( <span class="keyword">const</span> <span class="keywordtype">double</span> r, <span class="keywordtype">double</span>&amp; result);
00194   <span class="comment">/****</span>
00195 <span class="comment">       INPUT: r = norm(u-v)</span>
00196 <span class="comment">       OUTPUT: The value of the RBF at r. </span>
00197 <span class="comment">       EFFECT: calculates the value of the RBF indicated by the member choice at r.</span>
00198 <span class="comment">  ****/</span>  
00199 
00200   <span class="keywordtype">int</span> rbffamily; <span class="comment">// flag to choose the radial basis function</span>
00201   <span class="keywordtype">long</span> degree;    <span class="comment">// size of the polynomial basis</span>
00202   
00203   void (*phi)( <span class="keywordtype">double</span> r, <span class="keywordtype">double</span>&amp; result);
00204 
00205   <span class="keywordtype">double</span> c_;
00206   <span class="keywordtype">double</span> beta_;  <span class="comment">//</span>
00207   Vector&lt;double&gt; b;
00208   Vector&lt;double&gt; a;
00209 }; <span class="comment">// end class rbfapprox</span>
00210 
00211 <span class="preprocessor">#endif</span>
00212 <span class="preprocessor"></span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Sep 25 17:37:40 2007 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
