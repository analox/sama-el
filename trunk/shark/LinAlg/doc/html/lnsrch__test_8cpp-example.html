<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LinAlg: lnsrch_test.cpp</title>
<link href="LinAlg.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
  </ul></div>
<h1>lnsrch_test.cpp</h1>Does a line search, i.e. given a nonlinear function, a starting point and a direction, a new point is calculated where the function has decreased "sufficiently". The line search algorithms are based on the Newton method of approximating root values of monotone decreasing functions. When the derivative <img class="formulaInl" alt="$ f' $" src="form_8.png"> of the function <img class="formulaInl" alt="$ f $" src="form_1.png"> at a starting point <img class="formulaInl" alt="$ x $" src="form_9.png"> on the X-axis can be calculated, the intersection <img class="formulaInl" alt="$ x' $" src="form_10.png"> of the tangent at point <img class="formulaInl" alt="$ f(x) $" src="form_11.png"> (with gradient <img class="formulaInl" alt="$ f'(x) $" src="form_12.png">) with the X-axis can be used to get a better approximation of the minima at <img class="formulaInl" alt="$ x_{min} $" src="form_13.png">.<p>
This function is based on this idea: Given a nonlinear function <img class="formulaInl" alt="$ f $" src="form_1.png">, a n-dimensional starting point <img class="formulaInl" alt="$ x_{old} $" src="form_14.png"> and a direction <img class="formulaInl" alt="$ p $" src="form_15.png"> (known as Newton direction), a new point <img class="formulaInl" alt="$ x_{new} $" src="form_16.png"> is calculated as<p>
<img class="formulaInl" alt="$ x_{new} = x_{old} + \lambda p, \hspace{2em} 0 < \lambda \leq 1 $" src="form_17.png"><p>
in a way that <img class="formulaInl" alt="$ f(x_{new})$" src="form_18.png"> has decreased sufficiently. Sufficiently means that<p>
<img class="formulaInl" alt="$ f(x_{new}) \leq f(x_{old}) + \alpha \nabla f \cdot (x_{new} - x_{old}) $" src="form_19.png"><p>
where <img class="formulaInl" alt="$ 0 < \alpha < 1 $" src="form_20.png"> is a fraction of the initial rate of decrease <img class="formulaInl" alt="$ \nabla f \cdot p $" src="form_21.png">.<p>
This function can be used for minimization or solving a set of nonlinear equations of the form <img class="formulaInl" alt="$ F(x) = 0 $" src="form_22.png">. Finding the root value (the x-value at which the related function will intersect the X-axis) will then solve the equations. In contrast to cubic line search (<a class="el" href="cblnsrch_8cpp.html">cblnsrch.cpp</a>), here the root value can be calculated by only three gradient of function evaluations.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xold</em>&nbsp;</td><td>n-dimensional starting point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fold</em>&nbsp;</td><td>The value of function <em>func</em> at point <em>xold</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>The n-dimensional gradient of function <em>func</em> at point <em>xold</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>n-dimensional point to specify the search direction (the Newton direction). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>New n-dimensional point along the direction <em>p</em> from <em>xold</em> where the function <em>func</em> decreases "sufficiently". </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>The new function value for point <em>x</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stpmax</em>&nbsp;</td><td>No. of the steps <em>lnsrch</em>. will do internally, to limit the number avoids evaluating the function in regions where it is undefined or subject to overflow. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Set to <em>false</em> on a normal exit and to <em>true</em> when <em>x</em> is to close to <em>xold</em> (signals convergence for minimization algorithms). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>func</em>&nbsp;</td><td>Function to decrease. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check_exception</em>&nbsp;</td><td>the type of the exception will be "size mismatch" and indicates that <em>xold</em> is not one-dimensional or has not the same size than <em>g</em> or <em>p</em> or <em>x</em> </td></tr>
  </table>
</dl>
Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.<p>
<dl compact><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl compact><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl compact><dt><b>Status</b></dt><dd>stable</dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//===========================================================================</span>
<a name="l00051"></a>00051 <span class="comment"></span><span class="comment">//===========================================================================</span>
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="preprocessor">#include&lt;iostream&gt;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include "Array/Array.h"</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include "Array/ArrayIo.h"</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include "<a class="code" href="arrayoptimize_8h.html">LinAlg/arrayoptimize.h</a>"</span>
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="keyword">using namespace </span>std;
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 
<a name="l00061"></a>00061 <span class="comment">// Function to be decreased, implements f(x) = x*x</span>
<a name="l00062"></a>00062 <span class="comment">//</span>
<a name="l00063"></a>00063 <span class="keywordtype">double</span> my_func(<span class="keyword">const</span> Array&lt; double &gt; &amp;x)
<a name="l00064"></a>00064 {
<a name="l00065"></a>00065     <span class="keywordflow">return</span> x(0) * x(0);
<a name="l00066"></a>00066 }
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="comment">// Derivative function f'(x) = 2x of f(x) = x*x</span>
<a name="l00070"></a>00070 <span class="comment">//</span>
<a name="l00071"></a>00071 <span class="keywordtype">double</span> gradient(<span class="keywordtype">double</span> x)
<a name="l00072"></a>00072 {
<a name="l00073"></a>00073     <span class="keywordflow">return</span> 2*x;
<a name="l00074"></a>00074 }
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="keywordtype">int</span> main()
<a name="l00078"></a>00078 {
<a name="l00079"></a>00079 
<a name="l00080"></a>00080     Array&lt; double &gt; x_old(1),       <span class="comment">// old point</span>
<a name="l00081"></a>00081                     x_new(1),       <span class="comment">// new point</span>
<a name="l00082"></a>00082                     p(1),           <span class="comment">// Newton direction </span>
<a name="l00083"></a>00083                     grad(1);        <span class="comment">// gradient of function at old point</span>
<a name="l00084"></a>00084     <span class="keywordtype">double</span>          f_old(0.),      <span class="comment">// function-value of old point </span>
<a name="l00085"></a>00085                     f_new(0.),      <span class="comment">// function-value of new point</span>
<a name="l00086"></a>00086                     no_iter(1.);    <span class="comment">// no. of iterations, that</span>
<a name="l00087"></a>00087                                     <span class="comment">// "lnsrch" will do internally</span>
<a name="l00088"></a>00088     <span class="keywordtype">bool</span>            status(<span class="keyword">false</span>);  <span class="comment">// status of "lnsrch"-function</span>
<a name="l00089"></a>00089     <span class="keywordtype">unsigned</span>        i;              <span class="comment">// number of "lnsrch" iterations</span>
<a name="l00090"></a>00090  
<a name="l00091"></a>00091 
<a name="l00092"></a>00092     <span class="comment">// input points for "my_func":</span>
<a name="l00093"></a>00093     <span class="comment">//</span>
<a name="l00094"></a>00094     <span class="keywordtype">double</span> x_values[19] = 
<a name="l00095"></a>00095     {
<a name="l00096"></a>00096           -9., -8., -7., -6., 
<a name="l00097"></a>00097           -5., -4., -3., -2., -1.,  
<a name="l00098"></a>00098            0.,  1.,  2.,  3.,  4.,
<a name="l00099"></a>00099            5.,  6.,  7.,  8.,  9.
<a name="l00100"></a>00100     };
<a name="l00101"></a>00101 
<a name="l00102"></a>00102     <span class="comment">// Initialize values for first call of "lnsrch":</span>
<a name="l00103"></a>00103     <span class="comment">//</span>
<a name="l00104"></a>00104     x_old(0) = x_values[0];       <span class="comment">// starting point is -10.0 </span>
<a name="l00105"></a>00105     f_old = my_func(x_old);       <span class="comment">// Calculate function value of starting point</span>
<a name="l00106"></a>00106     grad(0) = gradient(x_old(0)); <span class="comment">// Calculate gradient of starting point</span>
<a name="l00107"></a>00107     p(0) = 10.;                   <span class="comment">// decrease function by going to</span>
<a name="l00108"></a>00108                                   <span class="comment">// the "right" on the X-axis.</span>
<a name="l00109"></a>00109     x_new(0) = x_old(0);          <span class="comment">// No new values calculated yet </span>
<a name="l00110"></a>00110     f_new = f_old;
<a name="l00111"></a>00111 
<a name="l00112"></a>00112     cout &lt;&lt; <span class="stringliteral">"Performing line search for function f(x) = x*x "</span>
<a name="l00113"></a>00113          &lt;&lt; <span class="stringliteral">"with starting point (-10, 100) and direction (10, 100):"</span> 
<a name="l00114"></a>00114          &lt;&lt; endl &lt;&lt; endl;
<a name="l00115"></a>00115 
<a name="l00116"></a>00116     <span class="comment">// Head for output of results:</span>
<a name="l00117"></a>00117     cout &lt;&lt; <span class="stringliteral">"status:\t\tnew point:\tfunction-value:\n"</span>;
<a name="l00118"></a>00118     cout &lt;&lt; <span class="stringliteral">"-------------------------------------------------------------\n"</span>;
<a name="l00119"></a>00119  
<a name="l00120"></a>00120     <span class="comment">// Presettings for formatted output:</span>
<a name="l00121"></a>00121     cout.setf(ios::fixed | ios::right | ios::internal | ios::showpos);
<a name="l00122"></a>00122     cout.precision(2);
<a name="l00123"></a>00123     cout.width(5);
<a name="l00124"></a>00124 
<a name="l00125"></a>00125     <span class="comment">// Output of starting values:</span>
<a name="l00126"></a>00126     cout &lt;&lt; <span class="stringliteral">"false"</span> &lt;&lt; <span class="stringliteral">"\t\t"</span> &lt;&lt; x_new(0) &lt;&lt; <span class="stringliteral">"\t\t"</span> &lt;&lt; f_new &lt;&lt; endl;     
<a name="l00127"></a>00127 
<a name="l00128"></a>00128     <span class="comment">// Take 15 "lnsrch" iterations:</span>
<a name="l00129"></a>00129     <span class="keywordflow">for</span> (i = 0; i &lt; 14; i++) 
<a name="l00130"></a>00130     {
<a name="l00131"></a>00131         <span class="comment">// Calculate next new point:</span>
<a name="l00132"></a>00132         <a name="a34"></a><a class="code" href="lnsrch_8cpp.html#748b23953390802421b9a0b2352fdab2">lnsrch</a>(x_old, f_old, grad, p, x_new, f_new, no_iter, status,my_func);
<a name="l00133"></a>00133 
<a name="l00134"></a>00134         <span class="comment">// Output of calculated results:</span>
<a name="l00135"></a>00135         <span class="keywordflow">if</span> (status == 0) cout &lt;&lt; <span class="stringliteral">"false"</span>; <span class="keywordflow">else</span> cout &lt;&lt; <span class="stringliteral">"true"</span>;
<a name="l00136"></a>00136             cout &lt;&lt; <span class="stringliteral">"\t\t"</span> &lt;&lt; x_new(0) &lt;&lt; <span class="stringliteral">"\t\t"</span> &lt;&lt; f_new &lt;&lt; endl;     
<a name="l00137"></a>00137 
<a name="l00138"></a>00138         <span class="comment">// Setting values for next iteration:</span>
<a name="l00139"></a>00139         x_old(0) = x_new(0);
<a name="l00140"></a>00140         f_old = f_new;
<a name="l00141"></a>00141         grad(0) = gradient(x_old(0));
<a name="l00142"></a>00142     }
<a name="l00143"></a>00143 
<a name="l00144"></a>00144     <span class="keywordflow">return</span> 0;
<a name="l00145"></a>00145 }
</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Wed Dec 16 13:06:53 2009 for LinAlg by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
