<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>krig.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">include</a></div>
<h1>krig.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/* krig.h</span>
00002 <span class="comment">written by Anthony Padula       adpadu@maila.wm.edu</span>
00003 <span class="comment">This file contains the class definition for a kriging approximator.</span>
00004 <span class="comment">When given a matrix of points and a vector of the</span>
00005 <span class="comment">function values at those points, will create a kriging</span>
00006 <span class="comment">approximation which can then be evaluated.</span>
00007 <span class="comment">This procedure is based on equations from a number of references.</span>
00008 <span class="comment"></span>
00009 <span class="comment"> *  Permission to use, copy, modify, and distribute this software  </span>
00010 <span class="comment"> *  for any purpose without fee is hereby granted, provided that   </span>
00011 <span class="comment"> *  this entire notice is included in all copies of any software   </span>
00012 <span class="comment"> *  which is or includes a copy or modification of this software   </span>
00013 <span class="comment"> *  and in all copies of the supporting documentation for such     </span>
00014 <span class="comment"> *  software.  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT    </span>
00015 <span class="comment"> *  ANY EXPRESS OR IMPLIED WARRANTY.  IN PARTICULAR, THE AUTHOR    </span>
00016 <span class="comment"> *  OFFERS NO REPRESENTATION OR WARRANTY OF ANY KIND                   </span>
00017 <span class="comment"> *  CONCERNING THE MERCHANTABILITY OF THIS SOFTWARE OR ITS    </span>
00018 <span class="comment"> *  FITNESS FOR ANY PARTICULAR PURPOSE.   </span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="comment">/* Instructions</span>
00022 <span class="comment">   1. create a krigapprox object with the statement:</span>
00023 <span class="comment">        krigapprox TestKRIG;</span>
00024 <span class="comment">   </span>
00025 <span class="comment">   2. run setvalues one of three ways:</span>
00026 <span class="comment">     a. TestKRIG.setvalues() will prompt the user for the necessary information.</span>
00027 <span class="comment">     However, this is only recommended for beginning users with small problems.</span>
00028 <span class="comment">     </span>
00029 <span class="comment">     b. TestKRIG.setvalues( filename ) will read in the same information as (a.) from the</span>
00030 <span class="comment">     file.  This is much quicker and is recommended for most problems.</span>
00031 <span class="comment"></span>
00032 <span class="comment">     c. TestKRIG.setvalues( Points, Values, deg, choice, c, beta) takes the</span>
00033 <span class="comment">     necessary info as parameters.  This is useful if you have created the</span>
00034 <span class="comment">     information at runtime.  See the function description below for details on</span>
00035 <span class="comment">     the parameters.</span>
00036 <span class="comment"></span>
00037 <span class="comment">   3. evaluate the function as often as desired.  This is done using:</span>
00038 <span class="comment">        TestKRIG.evalf( x);</span>
00039 <span class="comment">      where x is a Vector&lt;double&gt; of length p which contains the point at which</span>
00040 <span class="comment">      to evaluate.</span>
00041 <span class="comment"></span>
00042 <span class="comment"></span>
00043 <span class="comment">      NOTE: At this time, parameter estimation only works for correlation</span>
00044 <span class="comment">      functions 1 and 2.  Any other correlation function must be given</span>
00045 <span class="comment">      parameters by the user.  However, estimating mu always works, and will be</span>
00046 <span class="comment">      done in all cases.</span>
00047 <span class="comment">      </span>
00048 <span class="comment">     Last Modified 7/22/99</span>
00049 <span class="comment">*/</span>
00050 <span class="preprocessor">#ifndef KRIGA_H</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#define KRIGA_H</span>
00052 <span class="preprocessor"></span>
00053 <span class="preprocessor">#include "approx.h"</span>
00054 <span class="preprocessor">#include "gamma.h"</span>
00055 <span class="preprocessor">#include "ParamEstimate.h"</span>
00056 <span class="preprocessor">#include &lt;math.h&gt;</span>
00057 
00058 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00059 
00060 <span class="keyword">const</span> <span class="keywordtype">int</span> ALPHA = 2;  <span class="comment">// Currently used to select alpha, the parameter of the</span>
00061                       <span class="comment">// Gaussian correlation function.</span>
00062 
00063 <span class="keyword">const</span> <span class="keywordtype">double</span> DELTA = 0.05;  <span class="comment">// Currently used to select the starting delta for</span>
00064                             <span class="comment">// the parameter estimation.</span>
00065 
00066 <span class="keyword">const</span> <span class="keywordtype">int</span> DISPLAYK = 1; <span class="comment">// Sets the amount of output</span>
00067 <span class="comment">// 0 - dead silent</span>
00068 <span class="comment">// 1 - nothing but error messages</span>
00069 <span class="comment">// 2 - also outputs estimates of mu, theta, and tolerance</span>
00070 <span class="comment">// 4 - also LOTS of messages updating it's current position</span>
00071 <span class="comment">// 5 - also outputs most important matrices.  BE WARNED: Matrices are often HUGE</span>
00072 
00073 
00074 <span class="keyword">class </span>krigapprox: <span class="keyword">public</span> approx {
00075 <span class="keyword">public</span>:
00076   krigapprox(); 
00077   krigapprox( krigapprox&amp; ToBeCopied );
00078   krigapprox( Matrix&lt;double&gt;&amp; Points,  <span class="comment">// The n x p matrix of points, one point to a row</span>
00079               Vector&lt;double&gt;&amp; Values,  <span class="comment">// The vector of function values, so</span>
00080                                        <span class="comment">// f(Points[i])=Values[i] </span>
00081               <span class="keywordtype">int</span> choice); <span class="comment">// The flag for which correlation function to use</span>
00082                           <span class="comment">// (see chooseCorrelation() below)</span>
00083          
00084   krigapprox( Matrix&lt;double&gt;&amp; Points,  <span class="comment">// The n x p matrix of points, one point to a row</span>
00085               Vector&lt;double&gt;&amp; Values,  <span class="comment">// The vector of function values, so</span>
00086                                        <span class="comment">// f(Points[i])=Values[i] </span>
00087               <span class="keywordtype">int</span> choice, <span class="comment">// The flag for which correlation function to use</span>
00088                           <span class="comment">// (see chooseCorrelation() below)</span>
00089               <span class="keywordtype">double</span>* theta); <span class="comment">// The known value(s) of the parameter(s)</span>
00090   <span class="comment">// theta will either be a single number or an array of numbers.  If</span>
00091   <span class="comment">// there are multiple parameters,</span>
00092   <span class="comment">// they are expected to be stored in the array in order of increasing</span>
00093   <span class="comment">// dimension, and all theta_i before alpha_i.  Thus, in 3 dimensions, the</span>
00094   <span class="comment">// array might contain [1.0, 2.0, 3.0, 0.5, 4.5, 0] if theta_1 = 1.0, </span>
00095   <span class="comment">// theta_2 = 2.0, theta_3 = 3.0, alpha_1 = 0.5, alpha_2 = 4.5, alpha_3 = 0.0</span>
00096   <span class="comment">// See the chooseCorrelation() function below for more discussion of parameters</span>
00097 
00098   <span class="keyword">virtual</span> ~krigapprox(); <span class="comment">// Destructor</span>
00099 
00100   <span class="comment">// evalf returns the value of the function at the point passed in </span>
00101   <span class="comment">// point is a p-dim vector at which f is to be evaluated</span>
00102   <span class="keyword">virtual</span> <span class="keywordtype">double</span> evalf(<span class="keyword">const</span> Vector&lt;double&gt;&amp; point);
00103 
00104 
00105   <span class="comment">// evalderiv returns the vector value of the first derivative of the</span>
00106   <span class="comment">// interpolant at the point passed in.</span>
00107   <span class="comment">//</span>
00108   <span class="comment">// Note: in some cases, the derivative at interpolated points</span>
00109   <span class="comment">// is undefined.  The function will then print an error message</span>
00110   <span class="comment">// and return HUGE_VAL as the derivative  </span>
00111   <span class="comment">//</span>
00112   <span class="comment">//  STILL UNDER CONSTRUCTION done for 1,2,3,5</span>
00113   <span class="comment">// tested for 1,2,3</span>
00114   <span class="keyword">virtual</span> Vector&lt;double&gt; evalderiv( <span class="keyword">const</span> Vector&lt;double&gt;&amp; point);
00115 
00116   <span class="comment">/* virtual int setvalues();  </span>
00117 <span class="comment"></span>
00118 <span class="comment">     This is an I/O function to interactively set the necessary parameters</span>
00119 <span class="comment">     The data will be read in the format:</span>
00120 <span class="comment">     p = long integer  // the dimension of the space</span>
00121 <span class="comment">     n = long integer  // the number of points to be interpolated</span>
00122 <span class="comment">     choice = integer  // the choice of  which correlation function to use</span>
00123 <span class="comment">                       // (see chooseCorrelation() below)</span>
00124 <span class="comment">     query = y/n       // The program will then ask the user if</span>
00125 <span class="comment">                       // the parameters are known.</span>
00126 <span class="comment">                       // if 'y' then will prompt for the parameters</span>
00127 <span class="comment">                       // if 'n' then will estimate the parameters from the data</span>
00128 <span class="comment">     Points = a matrix of n x p+1 doubles, such that each row is one point follwed</span>
00129 <span class="comment">       by the function value at that point.  For example, if f( (2.3, 4.5) ) = 8.2,</span>
00130 <span class="comment">       then you would input:</span>
00131 <span class="comment">       2.3 4.5 8.2</span>
00132 <span class="comment"></span>
00133 <span class="comment">     This is the same format used by reportsample() and scanfunction() below</span>
00134 <span class="comment">  */</span>
00135   <span class="keyword">virtual</span> <span class="keywordtype">int</span> setvalues();  
00136 
00137   
00138   <span class="comment">/* virtual int setvalues(char* filename);</span>
00139 <span class="comment"></span>
00140 <span class="comment">     Reads the parameter values in order from a file and runs approximate() to</span>
00141 <span class="comment">     build the approximation</span>
00142 <span class="comment">     Returns 1 if successful, and 0 if insufficient data in the file.</span>
00143 <span class="comment">     Format is the same as the above.</span>
00144 <span class="comment">     Ex.</span>
00145 <span class="comment">     2</span>
00146 <span class="comment">     5</span>
00147 <span class="comment">     1</span>
00148 <span class="comment">     n</span>
00149 <span class="comment">     1.5 1.7 20.6</span>
00150 <span class="comment">     0.3 2.6 563.7</span>
00151 <span class="comment">     3.6 2.9 27.04</span>
00152 <span class="comment">     1.0 0.0 100.3</span>
00153 <span class="comment">     3.87 4.96 0.06</span>
00154 <span class="comment"></span>
00155 <span class="comment">     NOTE:  Will only read in parameters if necessary, depending on the 4th input.</span>
00156 <span class="comment">  */</span>
00157   <span class="keyword">virtual</span> <span class="keywordtype">int</span> setvalues(<span class="keywordtype">char</span>* filename);
00158   
00159 
00160   <span class="comment">/* This function works like the special constructor, allowing the data to be</span>
00161 <span class="comment">     passed in as parameters instead of being read from I/O.</span>
00162 <span class="comment">     Stores all data and calls approximate() to create the approximation</span>
00163 <span class="comment">  */</span>
00164   <span class="keyword">virtual</span> <span class="keywordtype">int</span> setvalues(  Matrix&lt;double&gt;&amp; Points, <span class="comment">// The n x p matrix of points, one point to a row</span>
00165                           Vector&lt;double&gt;&amp; Values,  <span class="comment">// The vector of function</span>
00166                                                    <span class="comment">// values, so f(Points[i])=Values[i]</span>
00167                           <span class="keywordtype">int</span> choice); <span class="comment">// The flag for which correlation function to use</span>
00168                                        <span class="comment">// (see chooseCorrelation() below)                        </span>
00169  
00170 
00171    <span class="comment">/* This function works like the special constructor, allowing the data to be</span>
00172 <span class="comment">     passed in as parameters instead of being read from I/O.</span>
00173 <span class="comment">     Stores all data and calls approximate() to create the approximation</span>
00174 <span class="comment">  */</span>
00175   <span class="keyword">virtual</span> <span class="keywordtype">int</span> setvalues( Matrix&lt;double&gt;&amp; Points,  <span class="comment">// The n x p matrix of points, one point to a row</span>
00176                          Vector&lt;double&gt;&amp; Values,  <span class="comment">// The vector of function values, so</span>
00177                                                   <span class="comment">// f(Points[i])=Values[i] </span>
00178                          <span class="keywordtype">int</span> choice, <span class="comment">// The flag for which correlation function to use</span>
00179                                      <span class="comment">// (see chooseCorrelation() below)</span>
00180                          <span class="keywordtype">double</span>* theta); <span class="comment">// The known value(s) of the parameter(s)</span>
00181   <span class="comment">// theta will either be a single number or an array of numbers.  If</span>
00182   <span class="comment">// there are multiple parameters,</span>
00183   <span class="comment">// they are expected to be stored in the array in order of increasing</span>
00184   <span class="comment">// dimension, and all theta_i before alpha_i.  Thus, in 3 dimensions, the</span>
00185   <span class="comment">// array might contain [1.0, 2.0, 3.0, 0.5, 4.5, 0] if theta_1 = 1.0, </span>
00186   <span class="comment">// theta_2 = 2.0, theta_3 = 3.0, alpha_1 = 0.5, alpha_2 = 4.5, alpha_3 = 0.0</span>
00187   <span class="comment">// See the chooseCorrelation() function below for more discussion of parameters</span>
00188 
00189  
00190   <span class="comment">/* void chooseCorrelationFamily( int choice );</span>
00191 <span class="comment">     </span>
00192 <span class="comment">     Allows the user to choose among the possible families of correlation</span>
00193 <span class="comment">     functions.  Will delete mu and theta and reapproximate if the other values</span>
00194 <span class="comment">     have been set.</span>
00195 <span class="comment">     </span>
00196 <span class="comment">     Currently, the options are:</span>
00197 <span class="comment">     </span>
00198 <span class="comment">     choice = 0  =&gt;  User defined function passed in previously</span>
00199 <span class="comment">     </span>
00200 <span class="comment">     choice = 1  =&gt;  Gaussian isotropic r(x,y) = exp( -theta * ||y-x||^alpha )</span>
00201 <span class="comment">     </span>
00202 <span class="comment">     choice = 2  =&gt;  Gaussian product \prod_{j=1}^{p} exp(-theta_j * |s_j - t_j|^alpha)</span>
00203 <span class="comment">     </span>
00204 <span class="comment">     choice = 3  =&gt;  Product of Linear  \prod_{j=1}^{p} (1-theta_j * |y_j - x_j|)</span>
00205 <span class="comment">     </span>
00206 <span class="comment">     choice = 5  =&gt;  Mate'rn correlation function</span>
00207 <span class="comment">                 \prod_{j=1}^{p} ((theta_j * |y_j - x_j|^alpha_j) /</span>
00208 <span class="comment">                 (2^(alpha_j -1) * gamma(alpha_j))) *</span>
00209 <span class="comment">                 K_{alpha_j}( theta_j * |y_j - x_j| )</span>
00210 <span class="comment"></span>
00211 <span class="comment">     where K_{nu}(x) is the degree nu modified Bessel function of the third order. </span>
00212 <span class="comment"></span>
00213 <span class="comment">     The default choice is Gaussian isotropic, so you really only need to run</span>
00214 <span class="comment">     this function in order to choose one of the other families.</span>
00215 <span class="comment">     </span>
00216 <span class="comment">     Notice that choices 2 and 3 take a vector of theta and a single alpha,</span>
00217 <span class="comment">     while choice 4 takes a vector of theta and a vector of alpha.  Your input</span>
00218 <span class="comment">     when running set values must be appropriate to the correlation function.</span>
00219 <span class="comment">  */</span>
00220   <span class="keywordtype">void</span> chooseCorrelationFamily( <span class="keywordtype">int</span> choice );
00221     
00222 
00223   <span class="comment">/* void chooseCorrelationFamily( int choice,   // indicates the correlation function</span>
00224 <span class="comment">                                double* theta ); // used for passing known</span>
00225 <span class="comment">                                                 // parameter values.  If values</span>
00226 <span class="comment">                                                 // unknown, pass in theta=NULL.</span>
00227 <span class="comment">  </span>
00228 <span class="comment">     Allows the user to choose among the possible families of correlation</span>
00229 <span class="comment">     functions.  If the user desires a correlation function not available as</span>
00230 <span class="comment">     one of the choices, then use of the chooseCorrelationFamily( void)</span>
00231 <span class="comment">     function below is recommended.</span>
00232 <span class="comment">     </span>
00233 <span class="comment">     Currently, the options are:</span>
00234 <span class="comment">     </span>
00235 <span class="comment">     choice = 0  =&gt;  User specified function (See below)</span>
00236 <span class="comment">      </span>
00237 <span class="comment">     choice = 1  =&gt;  Gaussian isotropic r(x,y) = exp( -theta * ||y-x||^alpha )</span>
00238 <span class="comment">     </span>
00239 <span class="comment">     choice = 2  =&gt;  Gaussian product \prod_{j=1}^{p} exp(-theta_j * |y_j - x_j|^alpha)</span>
00240 <span class="comment"></span>
00241 <span class="comment">     choice = 3  =&gt;  Product of Linear  \prod_{j=1}^{p} ( 1-theta_j*|y_j - x_j|)+</span>
00242 <span class="comment">                    </span>
00243 <span class="comment">     choice = 5  =&gt;  Mate'rn correlation function</span>
00244 <span class="comment">                    \prod_{j=1}^{p} ((theta_j * |y_j - x_j|^alpha_j) /</span>
00245 <span class="comment">                    (2^(alpha_j -1) * gamma(alpha_j))) *</span>
00246 <span class="comment">                    K_{alpha_j}( theta_j * |y_j - x_j| )</span>
00247 <span class="comment"></span>
00248 <span class="comment">     where K_{nu}(x) is the degree nu modified Bessel function of the third order. </span>
00249 <span class="comment"></span>
00250 <span class="comment">     The default choice is Gaussian isotropic, so you really only need to run</span>
00251 <span class="comment">     this function in order to choose one of the other families.  </span>
00252 <span class="comment"></span>
00253 <span class="comment">     Notice that choices 2 and 3 take a vector of theta and a single alpha,</span>
00254 <span class="comment">     while choice 4  and 5 takes a vector of theta and a vector of alpha.</span>
00255 <span class="comment">     Also, in choice 5, the values of alpha must be all integers.  Your input</span>
00256 <span class="comment">     when running set values must be appropriate to the correlation function.</span>
00257 <span class="comment">     </span>
00258 <span class="comment">     newrand() MUST be called after changing the correlation function, either</span>
00259 <span class="comment">     directly or via setvalues().  Otherwise your results will be nonsense.</span>
00260 <span class="comment">     </span>
00261 <span class="comment">     Theta &gt; 0!</span>
00262 <span class="comment">     </span>
00263 <span class="comment">     Warning: Do not use the Mate'rn family unless you really know how to set</span>
00264 <span class="comment">     the parameters.  Poor choices of parameters tend to cause problems with</span>
00265 <span class="comment">     the SVD.  The author of this code CANNOT guarentee proper functioning if</span>
00266 <span class="comment">     you use choice 5!  alpha &gt; 0 and alpha integer.  I suggest alpha=1 for all</span>
00267 <span class="comment">     alpha and theta around 3.</span>
00268 <span class="comment">  */</span>
00269   <span class="keywordtype">void</span> chooseCorrelationFamily( <span class="keywordtype">int</span> choice,  
00270                                 <span class="keywordtype">double</span>* theta );
00271   
00272 
00273   <span class="comment">/* void chooseCorrelationFamily( void (*corfunc)(const Vector&lt;double&gt;&amp; x,</span>
00274 <span class="comment">                                                const Vector&lt;double&gt;&amp; y,</span>
00275 <span class="comment">                                                double&amp; result ) );</span>
00276 <span class="comment">     This is an alternative to the previous function.  It allows the user to</span>
00277 <span class="comment">     pass in a correlation function of their own.  The correlation function</span>
00278 <span class="comment">     must accept two equal length vectors as input, and the double parameter is</span>
00279 <span class="comment">     used for output of the result.</span>
00280 <span class="comment">     </span>
00281 <span class="comment">     This sets the choice to option 0, and choosing another choice later will</span>
00282 <span class="comment">     use a different correlation function without overwriting the pointer.</span>
00283 <span class="comment">     Thus, you may switch back and forth between a hard-wired function and a</span>
00284 <span class="comment">     user specified function by indicating a new choice as directed above.</span>
00285 <span class="comment"></span>
00286 <span class="comment">     NOTE: NOT EVERY ARITHMETIC FUNCTION WORKS AS A CORRELATION FUNCTION</span>
00287 <span class="comment">  */</span> 
00288   <span class="keywordtype">void</span> chooseCorrelationFamily( <span class="keywordtype">void</span> (*corfunc)(<span class="keyword">const</span> Vector&lt;double&gt;&amp; <span class="comment">/*input*/</span> x,
00289                                                 <span class="keyword">const</span> Vector&lt;double&gt;&amp; <span class="comment">/*input*/</span> y,
00290                                                 <span class="keywordtype">double</span>&amp; <span class="comment">/*output*/</span> result ) );
00291 
00292 
00293   <span class="comment">// functions to get copies of the data members</span>
00294   
00295   <span class="comment">// Note that this returns pointer to an object which must be</span>
00296   <span class="comment">// deleted by user to avoid memory leak.</span>
00297   Vector&lt;double&gt;* gettheta(); 
00298   
00299   <span class="comment">// returns v = V(D^-1)U' y</span>
00300   Vector&lt;double&gt; getv();  
00301   
00302 
00303   <span class="comment">/****</span>
00304 <span class="comment">     Prints the data of the kriging to the output stream in the same format as it</span>
00305 <span class="comment">     would be read in from a file.  Thus, this function is appropriate for</span>
00306 <span class="comment">     storing functions so that they might be re-created later.</span>
00307 <span class="comment">  ****/</span>
00308   <span class="keywordtype">void</span> storeApprox( ostream&amp; outf );
00309 
00310   
00311 <span class="keyword">protected</span>:
00312 
00313   <span class="comment">/* This returns the value of the derivative of |a-b| with respect to b,</span>
00314 <span class="comment">   i.e. 1.0 or -1.0 . */</span>
00315   <span class="keywordtype">double</span> derivabs( <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b);
00316   
00317   <span class="comment">/* The value of the trend at this point */</span>
00318   <span class="keyword">virtual</span> <span class="keywordtype">double</span> trend( <span class="keyword">const</span> Vector&lt;double&gt; &amp; point);
00319 
00320   <span class="comment">/* The value of the first derivative of the trend at point */</span>
00321   <span class="keyword">virtual</span> Vector&lt;double&gt;* derivtrend( <span class="keyword">const</span> Vector&lt;double&gt; &amp; point);
00322  
00323   <span class="comment">// deallocates any dynamically allocated members and sets</span>
00324   <span class="comment">// them to NULL</span>
00325   <span class="keywordtype">void</span> deleteall(); 
00326 
00327   <span class="comment">// returns the proper number of parameters</span>
00328   <span class="keywordtype">int</span> thetasize();  
00329 
00330   <span class="comment">// returns the proper size of mu</span>
00331   <span class="keywordtype">int</span> musize();
00332 
00333   <span class="keywordtype">int</span> estimateTheta();
00334   <span class="keywordtype">void</span> estimateMu(<span class="keyword">const</span> Matrix&lt;double&gt; &amp; R);
00335   
00336   <span class="comment">// creates the approximation using the current values</span>
00337   <span class="comment">// Will estimate theta if necessary</span>
00338   <span class="comment">// Returns TRUE if Successful, FALSE otherwise.</span>
00339   <span class="keyword">virtual</span> <span class="keywordtype">int</span> approximate(); 
00340 
00341   <span class="comment">/****</span>
00342 <span class="comment">       virtual double correlation( const Vector&lt;double&gt;&amp; x, const Vector&lt;double&gt;&amp; y);</span>
00343 <span class="comment">       </span>
00344 <span class="comment">       INPUT: Two points x and y in the space</span>
00345 <span class="comment">       OUTPUT: The value of the correlation between them.  Currently, this uses the</span>
00346 <span class="comment">       Gaussian correlation function, but plans are to later allow the user</span>
00347 <span class="comment">       to select one of several correlation functions at the time of input</span>
00348 <span class="comment">       EFFECT: Calls l2norm() on the difference (ie. y - x ) of the vectors and then</span>
00349 <span class="comment">       calculates the Gaussian correlation.</span>
00350 <span class="comment">  ****/</span>  
00351    <span class="keyword">virtual</span> <span class="keywordtype">double</span> correlation( <span class="keyword">const</span> Vector&lt;double&gt;&amp; x, <span class="keyword">const</span> Vector&lt;double&gt;&amp; y);
00352 
00353   <span class="keywordtype">int</span> corfamily; <span class="comment">// flag to choose the correlation function</span>
00354   
00355   void (*corfunction)( <span class="keyword">const</span> Vector&lt;double&gt;&amp; x, <span class="keyword">const</span> Vector&lt;double&gt;&amp; y, <span class="keywordtype">double</span>&amp; result);
00356 
00357   <span class="keywordtype">double</span>* theta_;
00358   <span class="keywordtype">double</span>* mu_;
00359 
00360   Vector&lt;double&gt; v;  <span class="comment">// used by evalf</span>
00361 }; <span class="comment">// end class krigapprox</span>
00362 
00363 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Sep 25 17:37:40 2007 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
