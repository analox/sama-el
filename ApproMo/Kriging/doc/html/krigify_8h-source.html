<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>krigify.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">include</a></div>
<h1>krigify.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/* krigify.h</span>
00002 <span class="comment">written by Anthony Padula       adpadu@maila.wm.edu</span>
00003 <span class="comment">This file contains the function definitions for</span>
00004 <span class="comment">krigify and evalf to produce random functions</span>
00005 <span class="comment">with a specified trend, as if they were being</span>
00006 <span class="comment">drawn from a second-order Gaussian function.</span>
00007 <span class="comment">This procedure is described in</span>
00008 <span class="comment">        Trosset Michael W.</span>
00009 <span class="comment">        The Krigifier: A Procedure for Generating Pseudorandom</span>
00010 <span class="comment">        Nonlinear Objective Functions for Computational</span>
00011 <span class="comment">        Experimentation</span>
00012 <span class="comment"></span>
00013 <span class="comment">This is a modified version of krigify.h that has been upgraded to attempt to use</span>
00014 <span class="comment">the Cholesky factorization if possible.  If the Cholesky fails, it will default</span>
00015 <span class="comment">back to the SVD.</span>
00016 <span class="comment"></span>
00017 <span class="comment"> *  Permission to use, copy, modify, and distribute this software  </span>
00018 <span class="comment"> *  for any purpose without fee is hereby granted, provided that   </span>
00019 <span class="comment"> *  this entire notice is included in all copies of any software   </span>
00020 <span class="comment"> *  which is or includes a copy or modification of this software   </span>
00021 <span class="comment"> *  and in all copies of the supporting documentation for such     </span>
00022 <span class="comment"> *  software.  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT    </span>
00023 <span class="comment"> *  ANY EXPRESS OR IMPLIED WARRANTY.  IN PARTICULAR, THE AUTHOR    </span>
00024 <span class="comment"> *  OFFERS NO REPRESENTATION OR WARRANTY OF ANY KIND                   </span>
00025 <span class="comment"> *  CONCERNING THE MERCHANTABILITY OF THIS SOFTWARE OR ITS    </span>
00026 <span class="comment"> *  FITNESS FOR ANY PARTICULAR PURPOSE.   </span>
00027 <span class="comment"></span>
00028 <span class="comment">*/</span>
00029 
00030 <span class="comment">/* Instructions</span>
00031 <span class="comment">   1. Declare an randfunc object</span>
00032 <span class="comment">   2. run chooseCorrelationFamily(), if desired.  Otherwise, defaults</span>
00033 <span class="comment">      to using the Gaussian isotropic family.</span>
00034 <span class="comment">   3. run setvalues() to set the parameter values in order to define</span>
00035 <span class="comment">      the random function.  krigify() will automatically be called in this procedure.</span>
00036 <span class="comment">   4. call objectname.evalf(x) to evaluate the random function at a given</span>
00037 <span class="comment">      point x in the p-space.</span>
00038 <span class="comment">   5. repeat step 4 as many times as desired to produce a sample</span>
00039 <span class="comment">   6. a new random function can be defined simply by calling</span>
00040 <span class="comment">      objectname.newrand(), which generates a new X and v using the same</span>
00041 <span class="comment">      parameters, or objectname.newrandsameX(), which only generates a</span>
00042 <span class="comment">      new v. </span>
00043 <span class="comment">      Alternatively, objectname.setvalues() can also be called and fed new</span>
00044 <span class="comment">      parameters.</span>
00045 <span class="comment"></span>
00046 <span class="comment">      The text file krigifier_instructions.txt contains more thorough</span>
00047 <span class="comment">      instructions and explanations.</span>
00048 <span class="comment">      </span>
00049 <span class="comment">     Note:  It is possible to create the same function on repeated runs of the same</span>
00050 <span class="comment">     program.  If you use the same set of parameters, seed, and rng stream, you</span>
00051 <span class="comment">     will generate the same function.  Thus, in order to get a variety of </span>
00052 <span class="comment">     functions, it is IMPORTANT to use the special constructor and feed in</span>
00053 <span class="comment">     varying seeds and streams.  This is easy to do.  For example:</span>
00054 <span class="comment"></span>
00055 <span class="comment">     randfunc TestFunction( 2306, 14)</span>
00056 <span class="comment"></span>
00057 <span class="comment">     uses the seed 2306, and stream 14.  The seed can be any positive, long integer,</span>
00058 <span class="comment">     while the stream must be a positive integer between 0 and 255.</span>
00059 <span class="comment"></span>
00060 <span class="comment"></span>
00061 <span class="comment">     For a description of the necessary inputs, see the header for the setvalues()</span>
00062 <span class="comment">     function below.</span>
00063 <span class="comment">     </span>
00064 <span class="comment">     I have included a non-member function scanfunction() that takes an ofstream</span>
00065 <span class="comment">     and a randfunc object and outputs a thorough sample of data points from</span>
00066 <span class="comment">     the function which can be used for graphing.  scanfunction is only designed</span>
00067 <span class="comment">     for 2-D functions.</span>
00068 <span class="comment"></span>
00069 <span class="comment">     The class defaults to using a Gaussian isotropic correlation function, but</span>
00070 <span class="comment">     other choices are available through the chooseCorrelationFamily(int choice)</span>
00071 <span class="comment">     function.  If you change the correlation family after inputing parameters,</span>
00072 <span class="comment">     you will need to run newrand() again.  See the description below for more information</span>
00073 <span class="comment"></span>
00074 <span class="comment"></span>
00075 <span class="comment">     Last Modified 6/23/99</span>
00076 <span class="comment">*/</span>
00077 <span class="preprocessor">#ifndef KRIG_H</span>
00078 <span class="preprocessor"></span><span class="preprocessor">#define KRIG_H</span>
00079 <span class="preprocessor"></span>
00080 <span class="preprocessor">#include &lt;cmath&gt;</span>
00081 <span class="preprocessor">#include "maps_general.h"</span>
00082 <span class="preprocessor">#include "rvgs.h"</span>
00083 <span class="preprocessor">#include &lt;iostream&gt;</span>
00084 <span class="preprocessor">#include "gamma.h"</span>
00085 
00086 <span class="comment">/*</span>
00087 <span class="comment">#ifndef BOOL_C</span>
00088 <span class="comment">#define BOOL_C</span>
00089 <span class="comment">const int TRUE = 1;</span>
00090 <span class="comment">const int FALSE = 0;</span>
00091 <span class="comment">#endif</span>
00092 <span class="comment">*/</span>
00093 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00094 
00095 <span class="comment">/* Choose the appropriate machine epsilon for your system, or declare one with</span>
00096 <span class="comment">   the appropriate value.  If you don't know machine epsilon, it's easy to find:</span>
00097 <span class="comment"></span>
00098 <span class="comment">   macheps = 1;</span>
00099 <span class="comment">   do {</span>
00100 <span class="comment">      macheps = macheps/2.0;</span>
00101 <span class="comment">   } while ( 1+macheps &gt; 1);</span>
00102 <span class="comment">   macheps = macheps*2.0;</span>
00103 <span class="comment"></span>
00104 <span class="comment">   Or else just simply choose the MACHEPS = 1.0 option and the program will run</span>
00105 <span class="comment">   automatically to find the correct machine epsilon.</span>
00106 <span class="comment">*/</span>
00107 <span class="preprocessor">#ifndef MACHEPS_C</span>
00108 <span class="preprocessor"></span><span class="preprocessor">#define MACHEPS_C</span>
00109 <span class="preprocessor"></span><span class="comment">//const double MACHEPS = 2.22045e-16;     // For Suns</span>
00110 <span class="keyword">const</span> <span class="keywordtype">double</span> MACHEPS = 1.0842e-19;        <span class="comment">// For Pentiums</span>
00111 <span class="comment">//const double MACHEPS = ????             // Fill in your own here</span>
00112 
00113 <span class="comment">//const double MACHEPS = 1.0;             // If you don't know macheps, choose</span>
00114                                           <span class="comment">// this one, and it will be set</span>
00115                                           <span class="comment">// properly automatically</span>
00116 <span class="preprocessor">#endif</span>
00117 <span class="preprocessor"></span>
00118 <span class="keyword">class </span>randfunc {
00119 <span class="keyword">public</span>:
00120   <span class="comment">// Automatically takes seed from system clock.</span>
00121   <span class="comment">// Defaults to stream 42.</span>
00122   randfunc();
00123 
00124   <span class="comment">//  Note:  will copy seed along with other data, but will not re-seed the rng.  </span>
00125   randfunc( randfunc&amp; ToBeCopied );
00126 
00127   <span class="comment">// Use to feed a seed to rng when creating a new class object</span>
00128   randfunc( <span class="keywordtype">long</span> seedtoplant, <span class="keywordtype">int</span> stream );
00129 
00130   <span class="comment">// Destructor</span>
00131   <span class="keyword">virtual</span> ~randfunc(); 
00132 
00133    <span class="comment">/* evalf returns the value of the function specified by the parameters</span>
00134 <span class="comment">   of the evalf at the point x</span>
00135 <span class="comment"></span>
00136 <span class="comment">   x: A p-dim vector at which f is to be evaluated</span>
00137 <span class="comment">   */</span>
00138   <span class="keyword">virtual</span> <span class="keywordtype">double</span> evalf(<span class="keyword">const</span> Vector&lt;double&gt;&amp; x);
00139 
00140   <span class="comment">// evalderiv returns the vector value of the first derivative of the</span>
00141   <span class="comment">// interpolant at the point passed in.</span>
00142   <span class="comment">//</span>
00143   <span class="comment">// Note: in some cases, the derivative at interpolated points</span>
00144   <span class="comment">// is undefined.  The function will then print an error message</span>
00145   <span class="comment">// and return HUGE_VAL as the derivative  </span>
00146   <span class="comment">//</span>
00147   <span class="comment">// tested for correlation functions 1,2,3</span>
00148   <span class="keyword">virtual</span> Vector&lt;double&gt; evalderiv( <span class="keyword">const</span> Vector&lt;double&gt;&amp; point);
00149 
00150   <span class="comment">// Calls krigify to get new values for X and v</span>
00151   <span class="comment">// returns TRUE if successful</span>
00152   <span class="comment">//         FALSE if fails due to setvalues() not having</span>
00153   <span class="comment">//               been called previously</span>
00154   <span class="keywordtype">int</span> newrand();  
00155 
00156   <span class="comment">// Calls krigify to get new values for v</span>
00157   <span class="comment">// returns TRUE if successful</span>
00158   <span class="comment">//         FALSE if fails due to setvalues() not having</span>
00159   <span class="comment">//               been called previously</span>
00160   <span class="keywordtype">int</span> newrandsameX();
00161 
00162   <span class="comment">/* virtual void setvalues() </span>
00163 <span class="comment">     This is an I/O function to interactively set the parameter values</span>
00164 <span class="comment"></span>
00165 <span class="comment">     The data will be read in the format:</span>
00166 <span class="comment">     p = long integer</span>
00167 <span class="comment">     n = long integer</span>
00168 <span class="comment">     beta0 = double</span>
00169 <span class="comment">     beta1 = p doubling-point values separated by spaces</span>
00170 <span class="comment">     beta2 = p*p doubling-point values read along the rows</span>
00171 <span class="comment"></span>
00172 <span class="comment">        Ex. the Matlab matrix [1 2; 3 4] would be input</span>
00173 <span class="comment">        1 2 3 4</span>
00174 <span class="comment"></span>
00175 <span class="comment">     x0 = p doubling-point values separated by spaces</span>
00176 <span class="comment">     alpha = double                 //  NOTE: Will not request alpha or theta  </span>
00177 <span class="comment">     theta = double                 //  if using User specified correlation function</span>
00178 <span class="comment">     sigma2 = double</span>
00179 <span class="comment">     lower = p floating-point values separated by spaces</span>
00180 <span class="comment">     upper = p floating-point values separated by spaces</span>
00181 <span class="comment">     </span>
00182 <span class="comment">     X and v will be produced by the krigify function</span>
00183 <span class="comment">     </span>
00184 <span class="comment">     NOTE: Will not request beta's or x0 if using User specified trend</span>
00185 <span class="comment">     </span>
00186 <span class="comment">  */</span>
00187   <span class="keyword">virtual</span> <span class="keywordtype">void</span> setvalues(); 
00188 
00189   <span class="comment">/*  virtual int setvalues(char* filename);</span>
00190 <span class="comment">      </span>
00191 <span class="comment">      Reads the parameter values in order from a file and runs</span>
00192 <span class="comment">      krigify to get X and v.  Returns 1 if successful, and 0 if insufficient</span>
00193 <span class="comment">      data in the file.</span>
00194 <span class="comment">     </span>
00195 <span class="comment">      Format is the same as the above</span>
00196 <span class="comment">      </span>
00197 <span class="comment">      Ex.  Trosset's sample data on pg 6 of the aforementioned paper would be</span>
00198 <span class="comment">      2</span>
00199 <span class="comment">      200</span>
00200 <span class="comment">      50.0</span>
00201 <span class="comment">      0 0</span>
00202 <span class="comment">      100 0 0 100</span>
00203 <span class="comment">      0.3 0.4</span>
00204 <span class="comment">      1</span>
00205 <span class="comment">      50</span>
00206 <span class="comment">      100</span>
00207 <span class="comment">      0 0</span>
00208 <span class="comment">      1 1</span>
00209 <span class="comment"></span>
00210 <span class="comment">      NOTE: If using a User specified correlation function, then alpha and theta</span>
00211 <span class="comment">      should be omitted, and will be set to 0 automatically.  Thus, the input</span>
00212 <span class="comment">      would look like:</span>
00213 <span class="comment"></span>
00214 <span class="comment">      2</span>
00215 <span class="comment">      200</span>
00216 <span class="comment">      50.0</span>
00217 <span class="comment">      0 0</span>
00218 <span class="comment">      100 0 0 100</span>
00219 <span class="comment">      0.3 0.4</span>
00220 <span class="comment">      100</span>
00221 <span class="comment">      0 0</span>
00222 <span class="comment">      1 1</span>
00223 <span class="comment">      </span>
00224 <span class="comment">      NOTE: If using a User specified trend, then all beta's and x0 should be</span>
00225 <span class="comment">      omitted, Thus the input would look like:</span>
00226 <span class="comment">      </span>
00227 <span class="comment">      2</span>
00228 <span class="comment">      200</span>
00229 <span class="comment">      1</span>
00230 <span class="comment">      50</span>
00231 <span class="comment">      100</span>
00232 <span class="comment">      0 0</span>
00233 <span class="comment">      1 1</span>
00234 <span class="comment"></span>
00235 <span class="comment">      or if User specifing both correlation function and trend, then would look</span>
00236 <span class="comment">      like:</span>
00237 <span class="comment"></span>
00238 <span class="comment">      2</span>
00239 <span class="comment">      200</span>
00240 <span class="comment">      100</span>
00241 <span class="comment">      0 0</span>
00242 <span class="comment">      1 1</span>
00243 <span class="comment">  */</span>
00244   <span class="keyword">virtual</span> <span class="keywordtype">int</span> setvalues(<span class="keywordtype">char</span>* filename);
00245 
00246 
00247   <span class="comment">/*virtual int setvalues(long pin, long nin, double beta0in, Vector&lt;double&gt;&amp; beta1in,</span>
00248 <span class="comment">                        Matrix&lt;double&gt;&amp; beta2in, Vector&lt;double&gt;&amp; x0in, </span>
00249 <span class="comment">                        Vector&lt;double&gt;&amp; alphain, Vector&lt;double&gt;&amp; thetain, </span>
00250 <span class="comment">                        double sigma2in, Vector&lt;double&gt;&amp; lowerin,</span>
00251 <span class="comment">                        Vector&lt;double&gt;&amp; upperin);</span>
00252 <span class="comment"></span>
00253 <span class="comment">    Has the same effect as setvalues() except that information is passed as parameters </span>
00254 <span class="comment">    instead of being read from I/O.</span>
00255 <span class="comment">  */</span>
00256   <span class="keyword">virtual</span> <span class="keywordtype">int</span> setvalues(<span class="keywordtype">long</span> pin, <span class="keywordtype">long</span> nin, <span class="keywordtype">double</span> beta0in, Vector&lt;double&gt;&amp; beta1in,
00257                         Matrix&lt;double&gt;&amp; beta2in, Vector&lt;double&gt;&amp; x0in, 
00258                         Vector&lt;double&gt;&amp; alphain, Vector&lt;double&gt;&amp; thetain, 
00259                         <span class="keywordtype">double</span> sigma2in, Vector&lt;double&gt;&amp; lowerin,
00260                         Vector&lt;double&gt;&amp; upperin);
00261 
00262 
00263   <span class="comment">/*  void chooseCorrelationFamily( int choice );</span>
00264 <span class="comment">      </span>
00265 <span class="comment">      Allows the user to choose among the possible families of correlation</span>
00266 <span class="comment">      functions.  If the user desires a correlation function not available as</span>
00267 <span class="comment">      one of the choices, then use of the chooseCorrelationFamily( void)</span>
00268 <span class="comment">      function below is recommended.</span>
00269 <span class="comment"></span>
00270 <span class="comment">      Currently, the options are:</span>
00271 <span class="comment"></span>
00272 <span class="comment">      choice = 0  =&gt;  User specified function (See below)</span>
00273 <span class="comment">      </span>
00274 <span class="comment">      choice = 1  =&gt;  Gaussian isotropic r(x,y) = exp( -theta * ||y-x||^alpha )</span>
00275 <span class="comment"></span>
00276 <span class="comment">      choice = 2  =&gt;  Gaussian product \prod_{j=1}^{p} exp(-theta_j * |y_j - x_j|^alpha)</span>
00277 <span class="comment"></span>
00278 <span class="comment">      choice = 3  =&gt;  Product of Linear  \prod_{j=1}^{p} ( 1-theta_j*|y_j - x_j|)+</span>
00279 <span class="comment"></span>
00280 <span class="comment">      choice = 5  =&gt;  Mate'rn correlation function</span>
00281 <span class="comment">                    \prod_{j=1}^{p} ((theta_j * |y_j - x_j|^alpha_j) /</span>
00282 <span class="comment">                    (2^(alpha_j -1) * gamma(alpha_j))) *</span>
00283 <span class="comment">                    K_{alpha_j}( theta_j * |y_j - x_j| )</span>
00284 <span class="comment"></span>
00285 <span class="comment">      where K_{nu}(x) is the degree nu modified Bessel function of the third order. </span>
00286 <span class="comment"></span>
00287 <span class="comment">      The default choice is Gaussian isotropic, so you really only need to run</span>
00288 <span class="comment">      this function in order to choose one of the other families.  </span>
00289 <span class="comment"></span>
00290 <span class="comment">      Notice that choices 2 and 3 take a vector of theta and a single alpha,</span>
00291 <span class="comment">      while choice 4  and 5 takes a vector of theta and a vector of alpha.</span>
00292 <span class="comment">      Also, in choice 5, the values of alpha must be all integers.  Your input</span>
00293 <span class="comment">      when running set values must be appropriate to the correlation function.</span>
00294 <span class="comment">      </span>
00295 <span class="comment">      newrand() MUST be called after changing the correlation function, either</span>
00296 <span class="comment">      directly or via setvalues().  Otherwise your results will be nonsense.</span>
00297 <span class="comment"></span>
00298 <span class="comment">      Theta &gt; 0!</span>
00299 <span class="comment"></span>
00300 <span class="comment">      Warning: Do not use the Mate'rn family unless you really know how to set</span>
00301 <span class="comment">      the parameters.  Poor choices of parameters tend to cause problems with</span>
00302 <span class="comment">      the SVD.  The author of this code CANNOT guarentee proper functioning if</span>
00303 <span class="comment">      you use choice 5!  alpha &gt; 0 and alpha integer.  I suggest alpha=1 for all</span>
00304 <span class="comment">      alpha and theta around 3.</span>
00305 <span class="comment">  */</span>
00306   <span class="keywordtype">void</span> chooseCorrelationFamily( <span class="keywordtype">int</span> choice );  
00307 
00308   <span class="comment">/*  void chooseCorrelationFamily( void (*corfunc)(const Vector&lt;double&gt;&amp; x,</span>
00309 <span class="comment">                                                    const Vector&lt;double&gt;&amp; y,</span>
00310 <span class="comment">                                                    double&amp; result ) );</span>
00311 <span class="comment">      This is an alternative to the previous function.  It allows the user to</span>
00312 <span class="comment">      pass in a correlation function of their own.  The correlation function</span>
00313 <span class="comment">      must accept two equal length vectors as input, and the double parameter is</span>
00314 <span class="comment">      used for output of the result.</span>
00315 <span class="comment"></span>
00316 <span class="comment">      This sets the choice to option 0, and choosing another choice later will</span>
00317 <span class="comment">      use a different correlation function without overwriting the pointer.</span>
00318 <span class="comment">      Thus, you may switch back and forth between a hard-wired function and a</span>
00319 <span class="comment">      user specified function by indicating a new choice as directed above.</span>
00320 <span class="comment"></span>
00321 <span class="comment">      NOTE: NOT EVERY ARITHMETIC FUNCTION WORKS AS A CORRELATION FUNCTION</span>
00322 <span class="comment">  */</span> 
00323   <span class="keywordtype">void</span> chooseCorrelationFamily( <span class="keywordtype">void</span> (*corfunc)(<span class="keyword">const</span> Vector&lt;double&gt;&amp; <span class="comment">/*input*/</span> x,
00324                                                 <span class="keyword">const</span> Vector&lt;double&gt;&amp; <span class="comment">/*input*/</span> y,
00325                                                 <span class="keywordtype">double</span>&amp; <span class="comment">/*output*/</span> result ) );
00326   
00327 
00328   <span class="comment">/* void setTrend( void (*usertrend)( const Vector&lt;double&gt;&amp; x,</span>
00329 <span class="comment">                                       double&amp; result));</span>
00330 <span class="comment">     This allows the user to specify a non-quadratic trend function.  x is the</span>
00331 <span class="comment">     point at which the trend should be evaluated, and result is used to return</span>
00332 <span class="comment">     the value of the trend at x</span>
00333 <span class="comment"></span>
00334 <span class="comment">     NOTE: To return to using default quadratic trend, as long as setvalues()</span>
00335 <span class="comment">     has been executed to input beta's and x0 at some point, you may call setTrend(NULL)</span>
00336 <span class="comment">  */</span>
00337   <span class="keywordtype">void</span> setTrend( <span class="keywordtype">void</span> (*usertrend)( <span class="keyword">const</span> Vector&lt;double&gt;&amp; <span class="comment">/*input*/</span> x,
00338                                     <span class="keywordtype">double</span>&amp; <span class="comment">/*output*/</span> result));
00339 
00340   <span class="comment">/* void generateTrend( double tau2, double* beta0 );</span>
00341 <span class="comment"></span>
00342 <span class="comment">     This generates a psuedorandom quadratic trend.  If beta0 == NULL, we use a </span>
00343 <span class="comment">     default value of beta0 = 0.  We choose beta1 = 0.</span>
00344 <span class="comment">     We generate Y such that Y[i][j] are Normal(0,tau2) </span>
00345 <span class="comment">     and then set beta2 = transpose(Y) * Y * ( 1.0/(p+1)).  </span>
00346 <span class="comment">     x0 is Uniformly chosen from [lower+(upper-lower)/4, lower+(upper-lower)/2] </span>
00347 <span class="comment">     in each dimension</span>
00348 <span class="comment"></span>
00349 <span class="comment">     Our final trend is then beta0 + 0 + (x-x0)^T beta2 (x-x0)</span>
00350 <span class="comment"></span>
00351 <span class="comment">     If tau2 == -1, we use tau2 = 4*sigma2</span>
00352 <span class="comment"></span>
00353 <span class="comment">     This function should be run AFTER the values are set.  This means that you should </span>
00354 <span class="comment">     pass in some useless values for the beta's and x0 in the setvalues data, but these</span>
00355 <span class="comment">     values will be later ignored.</span>
00356 <span class="comment">  */</span>
00357   <span class="keywordtype">void</span> generateTrend(<span class="keywordtype">double</span>, <span class="keywordtype">double</span>* );
00358 
00359 
00360   <span class="comment">/* void chooseInitialDesign(int choice);</span>
00361 <span class="comment">     This allows the user to select which initial design (how X is chosen) is used.  </span>
00362 <span class="comment">     The default is choice == 1, Uniform Random Sampling</span>
00363 <span class="comment"></span>
00364 <span class="comment">     Currently, the options are:</span>
00365 <span class="comment"></span>
00366 <span class="comment">      choice = 0  =&gt;  User specified function (See below)</span>
00367 <span class="comment">      </span>
00368 <span class="comment">      choice = 1  =&gt;  Uniform Random Sampling</span>
00369 <span class="comment"></span>
00370 <span class="comment">      choice = 2  =&gt;  Latin Hypercubes</span>
00371 <span class="comment">  */</span>
00372   <span class="keywordtype">void</span> chooseInitialDesign(<span class="keywordtype">int</span> choice);
00373 
00374   <span class="comment">/*  void chooseInitialDesign( void (*userdesign)( const long p,</span>
00375 <span class="comment">                                                    const long n,</span>
00376 <span class="comment">                                                    const Vector&lt;double&gt;&amp; lower,</span>
00377 <span class="comment">                                                    const Vector&lt;double&gt;&amp; upper,</span>
00378 <span class="comment">                                                    Matrix&lt;double&gt;&amp; X) )</span>
00379 <span class="comment"></span>
00380 <span class="comment">     This allows the user to specify an alternative initial design.  The</span>
00381 <span class="comment">     initial design must accept four inputs: </span>
00382 <span class="comment">     p is the dimension of the space</span>
00383 <span class="comment">     n is the number of initial design sites (how many points in the space)</span>
00384 <span class="comment">     lower is the vector of lower bounds (rectangular spaces)</span>
00385 <span class="comment">     upper is the vector of upper bounds</span>
00386 <span class="comment"></span>
00387 <span class="comment">     X is then the matrix in which the points will be stored.  X is an n by p</span>
00388 <span class="comment">     matrix, with one point in each row.</span>
00389 <span class="comment">  */</span>
00390   <span class="keywordtype">void</span> chooseInitialDesign( <span class="keywordtype">void</span> (*userdesign)( <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="comment">/*input*/</span> p,
00391                                                 <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="comment">/*input*/</span> n,
00392                                      <span class="keyword">const</span> Vector&lt;double&gt;&amp; <span class="comment">/*input*/</span> lower,
00393                                      <span class="keyword">const</span> Vector&lt;double&gt;&amp; <span class="comment">/*input*/</span> upper,
00394                                            Matrix&lt;double&gt;&amp; <span class="comment">/*output*/</span> X) );    
00395  
00396 
00397   <span class="comment">// functions to get copies of the data members</span>
00398   <span class="keywordtype">long</span> getp();
00399   <span class="keywordtype">long</span> getn();
00400   <span class="keywordtype">double</span> getbeta0();
00401   Vector&lt;double&gt; getbeta1();
00402   Matrix&lt;double&gt; getbeta2();
00403   Vector&lt;double&gt; getx0();
00404   <span class="keywordtype">double</span> getalpha();
00405   <span class="keywordtype">double</span> gettheta();
00406   Matrix&lt;double&gt; getX();
00407   Vector&lt;double&gt; getv();
00408   Vector&lt;double&gt; getlower();
00409   Vector&lt;double&gt; getupper();
00410   <span class="keywordtype">long</span> getSeed();
00411   <span class="keywordtype">int</span> getStream();
00412   
00413 <span class="keyword">protected</span>:
00414 
00415   <span class="comment">/* This returns the value of the derivative of |a-b| with respect to b,</span>
00416 <span class="comment">   i.e. 1.0 or -1.0 . */</span>
00417   <span class="keywordtype">double</span> derivabs( <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b);
00418  
00419   <span class="comment">/* The value of the first derivative of the trend at point */</span>
00420   Vector&lt;double&gt;* derivtrend( <span class="keyword">const</span> Vector&lt;double&gt; &amp; point);
00421  
00422   <span class="comment">// generates a Latin Hypercube design and stores it in X.</span>
00423   <span class="keywordtype">void</span> genLH();
00424 
00425   <span class="comment">// Prints out an error message</span>
00426   <span class="keywordtype">void</span> notseterror();
00427 
00428   <span class="comment">// deletes all non-null dynamically allocated data members</span>
00429   <span class="keywordtype">void</span> deleteall(); 
00430   
00431   <span class="comment">// Generates the necessary random values and kriges them to produce</span>
00432   <span class="comment">// an approximate realization</span>
00433   <span class="comment">//</span>
00434   <span class="comment">// flag == 1  =&gt; create new X and v</span>
00435   <span class="comment">// flag == 2  =&gt; create new v using old X</span>
00436   <span class="keywordtype">void</span> krigify(<span class="keywordtype">int</span> flag); 
00437 
00438   <span class="comment">/**** virtual double correlation( const Vector&lt;double&gt;&amp; x, const Vector&lt;double&gt;&amp; y);</span>
00439 <span class="comment"></span>
00440 <span class="comment">       INPUT: Two points x and y in the space</span>
00441 <span class="comment">       OUTPUT: The value of the correlation between them.  Currently, this uses the</span>
00442 <span class="comment">       Gaussian correlation function, but plans are to later allow the user</span>
00443 <span class="comment">       to select one of several correlation functions at the time of input</span>
00444 <span class="comment">       EFFECT: Calls l2norm() on the difference (ie. y - x ) of the vectors and then</span>
00445 <span class="comment">       calculates the Gaussian correlation.</span>
00446 <span class="comment">  ****/</span>  
00447   <span class="keyword">virtual</span> <span class="keywordtype">double</span> correlation( <span class="keyword">const</span> Vector&lt;double&gt;&amp; x, <span class="keyword">const</span> Vector&lt;double&gt;&amp; y);
00448  
00449 
00450   <span class="keywordtype">int</span> ValuesSet;
00451   <span class="keywordtype">long</span> p;        <span class="comment">// dimension of the space</span>
00452   <span class="keywordtype">long</span> n;        <span class="comment">// number of sample sites</span>
00453   <span class="keywordtype">long</span> seed;
00454   <span class="keywordtype">int</span> rngstream;
00455 
00456   <span class="comment">// flag to choose correlation family</span>
00457   <span class="comment">// 1 =&gt; Gaussian Isotropic  r(x,y) = exp( -theta * ||y-x||^alpha )</span>
00458   <span class="comment">// 2 =&gt; Gaussian Product    r(x,y) = \prod_{j=1}^{P} exp(-theta * |s_j - t_j|^alpha)</span>
00459   <span class="comment">// 3 =&gt; Product of Linear   r(x,y) = \prod_{j=1}^{p} ( 1-theta*|y_j - x_j|)+</span>
00460   <span class="comment">// 4 =&gt; Cubic correlation on the unit cube</span>
00461   <span class="comment">//      r(x,y) = \prod_{j=1}^{p} ( 1 - theta*(y_j - x_j)^2 + alpha*(y_j - x_j)^3 )</span>
00462   <span class="keywordtype">int</span> corfamily;
00463 
00464   <span class="comment">// flag to choose the initial design</span>
00465   <span class="comment">// 1 =&gt; Uniform Random Sampling</span>
00466   <span class="comment">// 2 =&gt; Latin Hypercube</span>
00467   <span class="keywordtype">int</span> designchoice;
00468 
00469   void (*corfunction)( <span class="keyword">const</span> Vector&lt;double&gt;&amp; x, <span class="keyword">const</span> Vector&lt;double&gt;&amp; y, <span class="keywordtype">double</span>&amp; result);
00470   void (*trend)(<span class="keyword">const</span> Vector&lt;double&gt;&amp; x, <span class="keywordtype">double</span>&amp; result);
00471   void (*design)( <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="comment">/*input*/</span> p,
00472                       <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="comment">/*input*/</span> n,
00473                       <span class="keyword">const</span> Vector&lt;double&gt;&amp; <span class="comment">/*input*/</span> lower,
00474                       <span class="keyword">const</span> Vector&lt;double&gt;&amp; <span class="comment">/*input*/</span> upper,
00475                       Matrix&lt;double&gt;&amp; <span class="comment">/*output*/</span> X);
00476 
00477   Vector&lt;double&gt; *thetavec;  <span class="comment">// Vectors for storing the parameters of the </span>
00478   Vector&lt;double&gt; *alphavec;  <span class="comment">// alternate correlation functions. </span>
00479 
00480   <span class="comment">// these four parameters specify the quadratic trend</span>
00481   <span class="comment">// beta0 + (x-x0)^{T} beta1 + (x-x0)^{T} beta2 (x-x0)</span>
00482   <span class="keywordtype">double</span> beta0; 
00483   Vector&lt;double&gt; *beta1; 
00484   Matrix&lt;double&gt; *beta2; 
00485   Vector&lt;double&gt; *x0;    
00486    
00487   <span class="keywordtype">double</span> alpha;  <span class="comment">// specify the correlation function</span>
00488   <span class="keywordtype">double</span> theta;  <span class="comment">// specify the correlation function</span>
00489   <span class="keywordtype">double</span> sigma2; <span class="comment">// Variance</span>
00490   
00491   Vector&lt;double&gt; *lower; <span class="comment">// lower bound for each dimension</span>
00492   Vector&lt;double&gt; *upper; <span class="comment">// upper bound for each dimension</span>
00493   Matrix&lt;double&gt; X;  <span class="comment">// n random p-dimensional points (resized as necessary)</span>
00494   Vector&lt;double&gt; *v;  <span class="comment">// function values for the points in X    </span>
00495 }; <span class="comment">// end class randfunc</span>
00496 
00497 
00498 <span class="comment">/**** </span>
00499 <span class="comment">      void scanfunction( randfunc&amp; Func, ostream&amp; outf, int pointsperaxis);</span>
00500 <span class="comment"></span>
00501 <span class="comment">      INPUT: The randfunc object to be sampled and an ofstream to output the</span>
00502 <span class="comment">      values, as well as the number of points per axis to be sampled.  Thus, the</span>
00503 <span class="comment">      total number of sample points is approximately (pointsperaxis)^p.  Should</span>
00504 <span class="comment">      work for any value of p.</span>
00505 <span class="comment">      EFFECT: Outputs to the stream values in columns by axis.  For example:</span>
00506 <span class="comment"></span>
00507 <span class="comment">      2.3 3.4 13.695</span>
00508 <span class="comment">      </span>
00509 <span class="comment">      would correspond to the point (2.3, 3.4, 13.695) on the Cartesian</span>
00510 <span class="comment">      coordinate system.</span>
00511 <span class="comment">****/</span>
00512 <span class="keywordtype">void</span> scanfunction( randfunc&amp; Func, ostream&amp; outf, <span class="keywordtype">int</span> pointsperaxis);
00513 
00514 
00515 <span class="comment">// A default version which uses 25 pointsperaxis.  You can modify this default</span>
00516 <span class="comment">// by changing the 25 above.</span>
00517 <span class="keywordtype">void</span> scanfunction( randfunc&amp; Func, ostream&amp; outf);
00518 
00519 
00520 <span class="comment">/****</span>
00521 <span class="comment">     double reportsample( randfunc&amp; Func, Vector&lt;double&gt;&amp; x, ostream&amp; outf);</span>
00522 <span class="comment"></span>
00523 <span class="comment">     INPUT: The randfunc object to be sampled, the point at which to evaluate</span>
00524 <span class="comment">     the function, and the output stream to which it should report. </span>
00525 <span class="comment">     OUTPUT: the value of the function at x - result of Func.evalf(x)</span>
00526 <span class="comment">     EFFECT: Outputs to the stream the elements of x, seperated by spaces, and</span>
00527 <span class="comment">     then the function value at x, followed by an endline. For example:</span>
00528 <span class="comment"></span>
00529 <span class="comment">     1.0 2.0 3.0 4.0 5.0 6.0 21.0</span>
00530 <span class="comment"></span>
00531 <span class="comment">     would be written if x == (1.0, 2.0, 3.0, 4.0, 5.0, 6.0) and f(x) == 21.0</span>
00532 <span class="comment">****/</span>
00533 <span class="keywordtype">double</span> reportsample( randfunc&amp; Func, Vector&lt;double&gt;&amp; x, ostream&amp; outf);
00534 
00535 
00536 <span class="comment">/**** </span>
00537 <span class="comment">      void scanplane( randfunc&amp; Func, ostream&amp; outf, int pointsperaxis);</span>
00538 <span class="comment"></span>
00539 <span class="comment">      A simplified, but faster version of scanfunction().</span>
00540 <span class="comment">      ONLY works when p=2 !!!</span>
00541 <span class="comment">      </span>
00542 <span class="comment"></span>
00543 <span class="comment">      INPUT: The randfunc object to be sampled and an ofstream to output the</span>
00544 <span class="comment">      values.</span>
00545 <span class="comment">      EFFECT: Outputs to the stream values in columns by axis.  For example:</span>
00546 <span class="comment"></span>
00547 <span class="comment">      2.3 3.4 13.695</span>
00548 <span class="comment">      </span>
00549 <span class="comment">      would correspond to the point (2.3, 3.4, 13.695) on the Cartesian</span>
00550 <span class="comment">      coordinate system. </span>
00551 <span class="comment">****/</span>
00552 <span class="keywordtype">void</span> scanplane( randfunc&amp; Func, ostream&amp; outf, <span class="keywordtype">int</span> pointsperaxis);
00553 
00554 
00555 <span class="comment">/****</span>
00556 <span class="comment">     void analyzevalues( randfunc&amp; Func, ostream&amp; outf);</span>
00557 <span class="comment"></span>
00558 <span class="comment">     Works much like scanfunction, except that it reports simple statistics on</span>
00559 <span class="comment">     the points sampled to standard I/O, such as maximum value, minimum value,</span>
00560 <span class="comment">     average value, and the approximate location of the 25th and 75th</span>
00561 <span class="comment">     percentiles.</span>
00562 <span class="comment"></span>
00563 <span class="comment">     Uses a default value of 25 points per axis.</span>
00564 <span class="comment">     </span>
00565 <span class="comment">     Warning:  This function stores all sampled points in memory.  In higher</span>
00566 <span class="comment">     dimensions, this may fill up the available memory.  Use at your own risk.</span>
00567 <span class="comment">****/</span>
00568 <span class="keywordtype">void</span> analyzevalues( randfunc&amp; Func, ostream&amp; outf);
00569 
00570 <span class="comment">/****</span>
00571 <span class="comment">     void analyzevalues( randfunc&amp; Func, ostream&amp; outf, int pointsperaxis);</span>
00572 <span class="comment"></span>
00573 <span class="comment">     Works much like scanfunction, except that it reports simple statistics on</span>
00574 <span class="comment">     the points sampled to standard I/O, such as maximum value, minimum value,</span>
00575 <span class="comment">     average value, and the approximate location of the 25th and 75th</span>
00576 <span class="comment">     percentiles.</span>
00577 <span class="comment"></span>
00578 <span class="comment">     Divides each axis into pointsperaxis evenly spaced points, and samples at</span>
00579 <span class="comment">     each permutation of values.</span>
00580 <span class="comment">     </span>
00581 <span class="comment">     Warning:  This function stores all sampled points in memory.  In higher</span>
00582 <span class="comment">     dimensions, this may fill up the available memory.  Use at your own risk.</span>
00583 <span class="comment">****/</span>
00584 <span class="keywordtype">void</span> analyzevalues( randfunc&amp; Func, ostream&amp; outf, <span class="keywordtype">int</span> pointsperaxis);
00585 
00586 <span class="preprocessor">#endif</span>
00587 <span class="preprocessor"></span>
00588 
00589 
00590 
00591 
00592 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Sep 25 17:37:40 2007 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
