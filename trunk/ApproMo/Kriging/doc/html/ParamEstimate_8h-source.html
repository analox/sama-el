<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ParamEstimate.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">include</a></div>
<h1>ParamEstimate.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/****</span>
00002 <span class="comment">ParamEstimate Class - 6/27/00 cmsief</span>
00003 <span class="comment">This wonderfully useful class should take care of all of your parameter</span>
00004 <span class="comment">estimation needs.     </span>
00005 <span class="comment">****/</span>
00006 
00007 <span class="preprocessor">#ifndef _MAPS_PARAM_</span>
00008 <span class="preprocessor"></span><span class="preprocessor">#define _MAPS_PARAM_</span>
00009 <span class="preprocessor"></span>
00010 <span class="preprocessor">#include "maps_general.h"</span>
00011 <span class="preprocessor">#include "PatternSearch.h"</span>
00012 <span class="preprocessor">#include "f2c.h"</span>
00013 
00014 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00015 
00016 <span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00017   <span class="keywordtype">int</span> dgesvd_(<span class="keywordtype">char</span> *, <span class="keywordtype">char</span> *, <span class="keywordtype">long</span>*, <span class="keywordtype">long</span>*, <span class="keywordtype">double</span> *, <span class="keywordtype">long</span> *, <span class="keywordtype">double</span>*,
00018               <span class="keywordtype">double</span> *, <span class="keywordtype">long</span> *, <span class="keywordtype">double</span> *, <span class="keywordtype">long</span> *, <span class="keywordtype">double</span> *, <span class="keywordtype">long</span> *, <span class="keywordtype">long</span> *);
00019   <span class="keywordtype">int</span> dpotrf_(<span class="keywordtype">char</span>*, <span class="keywordtype">long</span>*, <span class="keywordtype">double</span>*, <span class="keywordtype">long</span>*, <span class="keywordtype">long</span>*);
00020   <span class="keywordtype">int</span> dpotri_(<span class="keywordtype">char</span>*, <span class="keywordtype">long</span>*, <span class="keywordtype">double</span>*, <span class="keywordtype">long</span>*, <span class="keywordtype">long</span>*);
00021 };
00022 <span class="comment">/*CLAPACK routines*/</span>
00023 
00024 <span class="preprocessor">#define START_THETA_STEP (0.1 * GetThetaUpperBound(curr_delta))</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#define STOP_THETA_STEP (0.000001 * GetThetaUpperBound(curr_delta))</span>
00026 <span class="preprocessor"></span>
00027 <span class="comment">/*correlation family numbers*/</span>
00028 <span class="comment">/*There are to be used to pick your correlation function type.</span>
00029 <span class="comment"> See the private member functions for more details.*/</span>
00030 <span class="preprocessor">#define COR_EXP_ISOTROPIC 0</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#define COR_GAUSS_ISOTROPIC 1</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#define COR_EXP_PRODUCT 2</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#define COR_GAUSS_PRODUCT 3</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#define COR_CUBIC_ISOTROPIC 4</span>
00035 <span class="preprocessor"></span>
00036 <span class="keyword">class </span>ParamEstimate {
00037 
00038 <span class="keyword">public</span>:
00039   ParamEstimate();
00040   ParamEstimate(ParamEstimate &amp;PE);
00041   ParamEstimate(<span class="keywordtype">long</span> dim);
00042   <span class="comment">/*Prep work and call SetDefault. This is the default.*/</span>
00043   ParamEstimate(<span class="keywordtype">int</span> correlate, <span class="keywordtype">long</span> dim, <a class="code" href="classPatternSearch.html">PatternSearch</a> &amp;PS1);
00044   <span class="comment">/*WARNING: REQUIRES A FULLY INITIALIZED PATTERNSEARCH*/</span>
00045   ~ParamEstimate();
00046   ParamEstimate&amp; operator=(ParamEstimate &amp;PE);
00047   
00048 
00049   <span class="comment">/*****RESET FUNCTIONS*****/</span>
00050 
00051   <span class="keywordtype">void</span> ResetParamEstimateState(<span class="keywordtype">int</span> correlate, <span class="keywordtype">long</span> dim, <a class="code" href="classPatternSearch.html">PatternSearch</a> &amp;PS1);
00052   <span class="comment">/****</span>
00053 <span class="comment">  INPUT: Correlation family number (see above), dimension of space, and a PatternSearch.</span>
00054 <span class="comment">  EFFECT: Resets all the major state variables.</span>
00055 <span class="comment">  ****/</span>
00056   
00057   <span class="keywordtype">void</span> ResetPatternSearch(<a class="code" href="classPatternSearch.html">PatternSearch</a> &amp;PS1);
00058   <span class="comment">/****</span>
00059 <span class="comment">  INPUT: PatternSearch Object.</span>
00060 <span class="comment">  EFFECT: Sets PS to be this PatternSearch.</span>
00061 <span class="comment">  ****/</span>
00062   
00063   <span class="keywordtype">bool</span> ResetCorrelationFamily(<span class="keywordtype">int</span> correlate);
00064   <span class="comment">/****</span>
00065 <span class="comment">  INPUT: Correlation family number (see above).</span>
00066 <span class="comment">  OUTPUT: True if number is valid.</span>
00067 <span class="comment">  EFFECT: Sets function pointer r to correct function.</span>
00068 <span class="comment">  ****/</span>
00069 
00070   <span class="keywordtype">bool</span> ResetDim(<span class="keywordtype">long</span> dim);
00071   <span class="comment">/****</span>
00072 <span class="comment">  INPUT: Dimension of the space.</span>
00073 <span class="comment">  OUTPUT: True if dimension is valid.</span>
00074 <span class="comment">  EFFECT: P=dim;</span>
00075 <span class="comment">  ****/</span>
00076 
00077   <span class="comment">/****QUERY FUNCTIONS****/</span>
00078   
00079   <span class="keywordtype">long</span> GetDim() <span class="keyword">const</span>;
00080   <span class="comment">/****</span>
00081 <span class="comment">  OUTPUT: Returns the dimension of the space.</span>
00082 <span class="comment">  ****/</span>
00083 
00084   <span class="keywordtype">long</span> GetThetaSize() <span class="keyword">const</span>;
00085   <span class="comment">/****</span>
00086 <span class="comment">  OUTPUT: Returns the size of the theta vector</span>
00087 <span class="comment">  ****/</span>     
00088   
00089   <span class="keywordtype">void</span> debug(<span class="keywordtype">char</span> *code) <span class="keyword">const</span>;
00090   <span class="comment">/****</span>
00091 <span class="comment">  EFFECT: Does a complete state dump to stdout.</span>
00092 <span class="comment">  ****/</span> 
00093 
00094   <span class="keyword">static</span> <span class="keywordtype">double</span> GetThetaUpperBound(<span class="keywordtype">double</span> delta);
00095   <span class="comment">/****</span>
00096 <span class="comment">  INPUT: delta.     </span>
00097 <span class="comment">  OUTPUT: Returns a double representing the upper bound for theta = -log(0.8) / curr_delta^2.</span>
00098 <span class="comment">  ****/</span> 
00099   
00100   <span class="comment">/*****ESTIMATION FUNCTIONS*****/</span>
00101   
00102   <span class="keywordtype">bool</span> EstimateConstantTrend(pt_collect &amp;pts, mp_vector &amp;fvals, <span class="keywordtype">double</span> delta, <span class="keywordtype">double</span>* beta,
00103                              <span class="keywordtype">double</span>* sigma2, mp_vector* theta, pt_collect*
00104                              MLE_Matrix, mp_vector* v);
00105   <span class="comment">/****</span>
00106 <span class="comment">  INPUT: Collection of evaluated points, their values, delta , and pointers for the</span>
00107 <span class="comment">  parameters to be returned.  theta should come in with a 'guess' value for the</span>
00108 <span class="comment">  optimizer to chew on.</span>
00109 <span class="comment">  OUTPUT: Returns true if the operation was successful.</span>
00110 <span class="comment">  EFFECT: This estimates the parameters, assuming a constant trend, and returns them.</span>
00111 <span class="comment">  ****/</span>
00112   
00113   <span class="keywordtype">bool</span> EstimateQuadraticTrend(pt_collect &amp;pts, mp_vector &amp;fvals, <span class="keywordtype">double</span> delta,
00114                               mp_vector* beta,                              
00115                               <span class="keywordtype">double</span>* sigma2, mp_vector* theta, pt_collect*
00116                               MLE_Matrix, mp_vector* v);
00117   <span class="comment">/****</span>
00118 <span class="comment">  INPUT: Collection of evaluated points, their values, and pointers for the</span>
00119 <span class="comment">  parameters to be returned. theta should come in with a 'guess' value for the</span>
00120 <span class="comment">  optimizer to chew on. </span>
00121 <span class="comment">  OUTPUT: Returns true if the operation was successful.</span>
00122 <span class="comment">  EFFECT: This estimates the parameters, using a quadratic trend constructed</span>
00123 <span class="comment">  using generalized least squares.  Then it returns the parameters.   </span>
00124 <span class="comment">  ****/</span>
00125  
00126   <span class="keywordtype">bool</span> EstimateCustomTrend(pt_collect &amp;pts, mp_vector &amp;fvals, <span class="keywordtype">double</span> delta, <span class="keywordtype">void</span>
00127                            (*fcn2)(<span class="keyword">const</span> mp_vector &amp;, mp_vector&amp;), <span class="keywordtype">long</span>
00128                            dimf, mp_vector* beta, <span class="keywordtype">double</span>* sigma2, mp_vector* theta,
00129                            pt_collect* MLE_Matrix, mp_vector* v);
00130   <span class="comment">/****</span>
00131 <span class="comment">  INPUT: Collection of evaluated points, their values, and pointers for the</span>
00132 <span class="comment">  parameters to be returned.  There is also a function pointer for the</span>
00133 <span class="comment">  'a' function, and the dimension of the vector it returns.  theta should come</span>
00134 <span class="comment">  in with a 'guess' value for the optimizer to chew on.</span>
00135 <span class="comment">  OUTPUT: Returns true if the operation was successful.</span>
00136 <span class="comment">  EFFECT: This estimates the function.</span>
00137 <span class="comment">  ****/</span> 
00138 
00139   <span class="keyword">friend</span> <span class="keywordtype">void</span> OptimizeMLEConstant(<span class="keywordtype">long</span> dimtheta, mp_vector &amp;x, <span class="keywordtype">double</span> &amp;f, <span class="keywordtype">bool</span> &amp;success,<span class="keywordtype">void</span>*PE) 
00140     {(*(ParamEstimate*)PE).MLEConstant(dimtheta,x,f,success);}
00141   <span class="comment">/****</span>
00142 <span class="comment">  INPUT: PatternSearch calling scheme.  See PatternSearch.h</span>
00143 <span class="comment">  EFFECT: Indirection to get around C++'s inability to let function pointer</span>
00144 <span class="comment">  point to class member functions.  This gets optimized by PatternSearch.</span>
00145 <span class="comment">  ****/</span>
00146 
00147   <span class="keyword">friend</span> <span class="keywordtype">void</span> OptimizeMLEQuadratic(<span class="keywordtype">long</span> dimtheta, mp_vector &amp;x, <span class="keywordtype">double</span> &amp;f, <span class="keywordtype">bool</span> &amp;success,<span class="keywordtype">void</span> *PE) 
00148     {(*(ParamEstimate*)PE).MLEQuadratic(dimtheta,x,f,success);}
00149   <span class="comment">/****</span>
00150 <span class="comment">  INPUT: PatternSearch calling scheme.  See PatternSearch.h</span>
00151 <span class="comment">  EFFECT: Indirection to get around C++'s inability to let function pointer</span>
00152 <span class="comment">  point to class member functions.  This gets optimized by PatternSearch.</span>
00153 <span class="comment">  ****/</span>
00154 
00155   <span class="keyword">friend</span> <span class="keywordtype">void</span> OptimizeMLECustom(<span class="keywordtype">long</span> dimtheta, mp_vector&amp;x, <span class="keywordtype">double</span> &amp;f, <span class="keywordtype">bool</span> &amp;success, <span class="keywordtype">void</span> *PE)
00156   {(*(ParamEstimate*)PE).MLECustom(dimtheta,x,f,success);}
00157   <span class="comment">/****</span>
00158 <span class="comment">  INPUT: PatternSearch calling scheme.  See PatternSearch.h</span>
00159 <span class="comment">  EFFECT: Indirection to get around C++'s inability to let function pointer</span>
00160 <span class="comment">  point to class member functions.  This gets optimized by PatternSearch.</span>
00161 <span class="comment">  ****/</span>
00162 
00163   <span class="keywordtype">double</span> EvaluateMyCorrelation(<span class="keywordtype">long</span> dim, <span class="keyword">const</span> mp_vector &amp;x1, <span class="keyword">const</span> mp_vector &amp;x2,
00164                                <span class="keyword">const</span> mp_vector &amp;theta);
00165   <span class="comment">/****</span>
00166 <span class="comment">  INPUT: Dimesion of space, two points, and a 'vector' theta.  For the Isotropic functions, this</span>
00167 <span class="comment">  theta is a one dimensional vector, for the Product functions, this is a</span>
00168 <span class="comment">  P-dimensional vector.</span>
00169 <span class="comment">  OUTPUT: Correlation between the two points.</span>
00170 <span class="comment">  ****/</span>       
00171 
00172 <span class="keyword">private</span>:
00173   
00174   <span class="keywordtype">void</span> SetDefault(<span class="keywordtype">long</span> dim);
00175   <span class="comment">/****</span>
00176 <span class="comment">  INPUT: Dimension of the space.</span>
00177 <span class="comment">  EFFECTS: This will use a happy default set of values to set up the parameter</span>
00178 <span class="comment">  estimation. </span>
00179 <span class="comment">  ****/</span> 
00180 
00181   <span class="comment">/*For the Optimization*/</span>
00182 
00183   <span class="keywordtype">void</span> MLEConstant(<span class="keywordtype">long</span> dimtheta, mp_vector &amp;x, <span class="keywordtype">double</span> &amp;f, <span class="keywordtype">bool</span> &amp;success);
00184   <span class="comment">/****</span>
00185 <span class="comment">  INPUT: PatternSearch calling scheme.  See PatternSearch.h</span>
00186 <span class="comment">  EFFECT: Evaluates the MLE for a given theta.  Uses the constant trend.  This</span>
00187 <span class="comment">  is to be optimized by the Pattern Search, via a little bit of indirection.</span>
00188 <span class="comment">  ****/</span>
00189 
00190   <span class="keywordtype">void</span> MLEQuadratic(<span class="keywordtype">long</span> dimtheta, mp_vector &amp;x, <span class="keywordtype">double</span> &amp;f, <span class="keywordtype">bool</span> &amp;success);
00191   <span class="comment">/****</span>
00192 <span class="comment">  INPUT: PatternSearch calling scheme.  See PatternSearch.h</span>
00193 <span class="comment">  EFFECT: Evaluates the MLE for a given theta.  Uses the quadratic trend.  This</span>
00194 <span class="comment">  is to be optimized by the Pattern Search, via a little bit of indirection.</span>
00195 <span class="comment">  ****/</span>  
00196 
00197   <span class="keywordtype">void</span> MLECustom(<span class="keywordtype">long</span> dimtheta, mp_vector &amp;x, <span class="keywordtype">double</span> &amp;f, <span class="keywordtype">bool</span> &amp;success);
00198   <span class="comment">/****</span>
00199 <span class="comment">  INPUT: PatternSearch calling scheme.  See PatternSearch.h</span>
00200 <span class="comment">  EFFECT: Evaluates the MLE for a given theta.  Uses the custom trend.  This is</span>
00201 <span class="comment">  to be optimized by the Pattern Search, via a little bit of indirection.</span>
00202 <span class="comment">  ****/</span>
00203   
00204   <span class="keywordtype">bool</span> pseudoinvert(pt_collect &amp;M, <span class="keywordtype">double</span> *log_det);
00205   <span class="comment">/****</span>
00206 <span class="comment">  INPUT: A matrix M, and a pointer to a mp_vector.</span>
00207 <span class="comment">  OUTPUT: true if svd can be computed, else false.</span>
00208 <span class="comment">  EFFECT: Replaces M with the inverse (if possible) or pseudoinverse of M.  If</span>
00209 <span class="comment">  d!=NULL, an mp_vector with the one over the singular values, with those singular</span>
00210 <span class="comment">  values below TOLERENCE instead to zero, is returned.  The matrix has to be</span>
00211 <span class="comment">  *SYMMETRIC AND SQUARE* for this to work.</span>
00212 <span class="comment">  ****/</span>
00213 
00214   <span class="keyword">inline</span> <span class="keywordtype">void</span> GenerateCorrelationMatrix(pt_collect &amp;R, <span class="keyword">const</span> mp_vector &amp;theta);
00215   <span class="comment">/****</span>
00216 <span class="comment">  INPUT: A np x np pt_collect, and the correlation family parameter vector, theta.</span>
00217 <span class="comment">  EFFECT: Replaces R with the appropriate correlation matrix.</span>
00218 <span class="comment">  ****/</span>
00219   
00220   <span class="comment">//  MARKUS bool ParamEstimate::ComputeCholeskyInverse(pt_collect *A,double* log_det);</span>
00221   <span class="keywordtype">bool</span> ComputeCholeskyInverse(pt_collect *A,<span class="keywordtype">double</span>* log_det);
00222   <span class="comment">/****</span>
00223 <span class="comment">  INPUT: Matrix A,  which should be positive definite, of which to find the</span>
00224 <span class="comment">  inverse using the Cholesky factorization and a pointer to the matrix in which to</span>
00225 <span class="comment">  store the inverse INV.  A * INV == I.  Also a pointer to a double.</span>
00226 <span class="comment">  OUTPUT: true if CLAPACK's dpotri_ returns OK.</span>
00227 <span class="comment">  EFFECT: Calls CLAPACK's dpotrf_ routine to compute the Cholesky factorization</span>
00228 <span class="comment">  of A, and then calls doprti_ to find the inverse from it.  Computes the</span>
00229 <span class="comment">  log determinant of A iff log_det!=NULL, and stores it in log_det.</span>
00230 <span class="comment">  Based roughly on Anthony Padula's code, modified by Chris Siefert.</span>
00231 <span class="comment">  ****/</span> 
00232 
00233   
00234   <span class="keywordtype">bool</span> ComputeSVDInverse(pt_collect *A, <span class="keywordtype">double</span> *log_det);
00235   <span class="comment">/****</span>
00236 <span class="comment">  INPUT: Matrix A, to take the SVD of and a pointer for the log_det.</span>
00237 <span class="comment">  OUTPUT: true if CLAPACK's dgesvd_ returns ok.</span>
00238 <span class="comment">  EFFECT: Calls CLAPACK's dgesvd routine to compute the Singular Value</span>
00239 <span class="comment">  Decomposition(SVD) of A.  Recall that a SVD of A yields U, D, and V',</span>
00240 <span class="comment">  s.t. A=U*D* V', where U and V are orthogonal matrices, and D is a diagonal</span>
00241 <span class="comment">  matrix with the singular values on its main diagonal.  The pseudoinverse is</span>
00242 <span class="comment">  computed, (Ai = V*Di*U') using the tolerance from Matlab. The log determinant is</span>
00243 <span class="comment">  calculated if log_det!=NULL, and it is stored there.   </span>
00244 <span class="comment">  ****/</span>  
00245 
00246 <span class="comment">/*</span>
00247 <span class="comment">  Correlation Functions</span>
00248 <span class="comment">  INPUT: Dimesion of space, two points, and a 'vector' theta.  For the Isotropic functions, this</span>
00249 <span class="comment">  theta is a one dimensional vector, for the Product functions, this is a</span>
00250 <span class="comment">  P-dimensional vector.</span>
00251 <span class="comment">  NOTE: You specify these by use of the integer #defined correlation family</span>
00252 <span class="comment">  numbers, and ResetCorrelationFamily().  These are static class member functions.</span>
00253 <span class="comment">*/</span>
00254 
00255 <span class="keyword">static</span> <span class="keywordtype">double</span> Cor_Exp_Isotropic(<span class="keywordtype">long</span> dim, <span class="keyword">const</span> mp_vector &amp;x1, <span class="keyword">const</span> mp_vector &amp;x2,
00256                                   <span class="keyword">const</span> mp_vector &amp;theta);
00257   <span class="comment">/*Exponential Isotropic Correlation Family</span>
00258 <span class="comment">    r_theta(s,t) = exp(-theta ||s-t||)</span>
00259 <span class="comment">  */</span>
00260 <span class="keyword">static</span> <span class="keywordtype">double</span> Cor_Gauss_Isotropic(<span class="keywordtype">long</span> dim, <span class="keyword">const</span> mp_vector &amp;x1, <span class="keyword">const</span> mp_vector &amp;x2,
00261                            <span class="keyword">const</span> mp_vector &amp;theta);
00262   <span class="comment">/*Gaussian Isotropic Correlation Family</span>
00263 <span class="comment">    r_theta(s,t) = exp(-theta ||s-t||)^2</span>
00264 <span class="comment">  */</span>  
00265 <span class="keyword">static</span> <span class="keywordtype">double</span> Cor_Exp_Product(<span class="keywordtype">long</span> dim, <span class="keyword">const</span> mp_vector &amp;x1, <span class="keyword">const</span> mp_vector &amp;x2, <span class="keyword">const</span>
00266                        mp_vector &amp;theta);
00267   <span class="comment">/*Exponential Product Correlation Family</span>
00268 <span class="comment">    r_theta(s,t) = \prod_{j=1}^{P} exp(-theta_j * |s_j - t_j|)</span>
00269 <span class="comment">  */</span>
00270 <span class="keyword">static</span> <span class="keywordtype">double</span> Cor_Gauss_Product(<span class="keywordtype">long</span> dim, <span class="keyword">const</span> mp_vector &amp;x1, <span class="keyword">const</span> mp_vector &amp;x2,
00271                          <span class="keyword">const</span> mp_vector &amp;theta);
00272   <span class="comment">/*Gaussian Product Correlation Family</span>
00273 <span class="comment">    r_theta(s,t) = \prod_{j=1}^{P} exp(-theta_j * |s_j - t_j|^2)</span>
00274 <span class="comment">  */</span>
00275 <span class="keyword">static</span> <span class="keywordtype">double</span> Cor_Cubic_Isotropic(<span class="keywordtype">long</span> dim, <span class="keyword">const</span> mp_vector &amp;x1, <span class="keyword">const</span> mp_vector &amp;x2,
00276                          <span class="keyword">const</span> mp_vector &amp;theta);
00277   <span class="comment">/*Cubic Product Correlation Family</span>
00278 <span class="comment">    r_theta(s,t) = { 1-1.5*(||s-t||)/theta + 0.5 ((||s-t||)/theta)^3, for ||s-t|| &lt; theta }</span>
00279 <span class="comment">                   { 0 otherwise }</span>
00280 <span class="comment">  */</span>
00281   
00282 <span class="keyword">private</span>:
00283   
00284   pt_collect* points;   <span class="comment">/*pointer to the evaluated points*/</span>
00285   mp_vector* values;    <span class="comment">/*pointer to function values*/</span>
00286   <span class="keywordtype">long</span> np;              <span class="comment">/*number of point evaluated*/</span>
00287 
00288   <a class="code" href="classPatternSearch.html">PatternSearch</a>* PS;    <span class="comment">/*some kind of optimizer*/</span>
00289   <span class="keywordtype">long</span> P;               <span class="comment">/*dimension of the space*/</span>
00290   double (*r)(<span class="keywordtype">long</span> dim,<span class="keyword">const</span> mp_vector&amp;, <span class="keyword">const</span> mp_vector&amp;, <span class="keyword">const</span> mp_vector&amp; );
00291   <span class="comment">/*for pointing to the correlation function*/</span>
00292   <span class="keywordtype">long</span> fdim;            <span class="comment">/*dimension of the vector returned by fcn*/</span>
00293   void (*fcn)(<span class="keyword">const</span> mp_vector &amp;, mp_vector&amp;);
00294   <span class="comment">/*for pointing to the 'A' function in custom estimation*/</span>
00295   <span class="keywordtype">double</span> curr_delta;    <span class="comment">/*Current delta. Used for bounds on theta*/</span>
00296   <span class="keywordtype">double</span> MACH_EPS;      <span class="comment">/*Machine Epsilon*/</span>
00297 };<span class="comment">/*end class*/</span>
00298 
00299 <span class="keywordtype">double</span> GetMachineEpsilon();
00300 
00301 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Sep 25 17:37:40 2007 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
