<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>cmat.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">include</a></div>
<h1>cmat.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">// Template Numerical Toolkit (TNT) for Linear Algebra</span>
00002 <span class="comment">//</span>
00003 <span class="comment">// BETA VERSION INCOMPLETE AND SUBJECT TO CHANGE</span>
00004 <span class="comment">// Please see http://math.nist.gov/tnt for updates</span>
00005 <span class="comment">//</span>
00006 <span class="comment">// R. Pozo</span>
00007 <span class="comment">// Mathematical and Computational Sciences Division</span>
00008 <span class="comment">// National Institute of Standards and Technology</span>
00009 
00010 <span class="comment">// Modified 6/2003 to make it work with new compilers.</span>
00011 <span class="comment">//    P.L. (Anne) Shepherd</span>
00012 
00013 <span class="comment">// ***********************************************************</span>
00014 <span class="comment">// ****IMPORTANT NOTE:</span>
00015 <span class="comment">//     I have modified this code so the overloaded reference</span>
00016 <span class="comment">//         operator () has C-type 0-based indexing.  This is </span>
00017 <span class="comment">//         a CHANGE from the original, which uses Fortran-type</span>
00018 <span class="comment">//         1-based indexing.  Any program that calls the operator</span>
00019 <span class="comment">//         in this version of cppmat.h expecting 1-based indexing,</span>
00020 <span class="comment">//         or uses an old version of cppmat.h and expects 0-based</span>
00021 <span class="comment">//         indexing, will get BAD RESULTS.  Please BE SURE</span>
00022 <span class="comment">//         you know which version of cppmat.h you are using and </span>
00023 <span class="comment">//         which one you need to be using.</span>
00024 <span class="comment">//           ----Anne Shepherd, 6/17/03   ********************</span>
00025 <span class="comment">// ***********************************************************</span>
00026 
00027 <span class="comment">// C compatible matrix: row-oriented, 0-based [i][j] and 1-based (i,j) indexing</span>
00028 <span class="comment">//</span>
00029 <span class="comment">// Chris Siefert's modified namespace free version - 5/26/99</span>
00030 <span class="comment">// function (row) has been added.  </span>
00031 <span class="comment">//    It returns the vector that contains that row.</span>
00032 <span class="comment">// function (col) has been added.  </span>
00033 <span class="comment">//    It returns the vector that contains that column.</span>
00034 <span class="comment">// Also, support for multiplication by a scalar has been added.</span>
00035 <span class="comment">// Support for Vector * Matrix acting as if the vector was a row </span>
00036 <span class="comment">//    vector is added.</span>
00037 
00038 <span class="comment">//Since Mr. Pozo never did it, here is the complete catalog of outside</span>
00039 <span class="comment">//accessable Matrix operations:</span>
00040 <span class="comment">//</span>
00041 <span class="comment">// Matrix&lt;T&gt;&amp; newsize(Subscript M, Subscript N) - resize matrix</span>
00042 <span class="comment">// operator T**(){ return  row_;} - ???</span>
00043 <span class="comment">// Subscript size() const { return mn_; }</span>
00044 <span class="comment">// operator = Matrix</span>
00045 <span class="comment">// operator = scalar - assigns all elements to the scalar.</span>
00046 <span class="comment">// Subscript dim(Subscript d)</span>
00047 <span class="comment">// num_rows() </span>
00048 <span class="comment">// num_cols() </span>
00049 <span class="comment">// operator[](Subscript i)</span>
00050 <span class="comment">// operator()(Subscript i)</span>
00051 <span class="comment">// operator()(Subscript i, Subscript j)</span>
00052 <span class="comment">// ostream &lt;&lt; Matrix</span>
00053 <span class="comment">// istream &gt;&gt; Matrix</span>
00054 <span class="comment">// Region operator()(const Index1D &amp;I, const Index1D &amp;J) - ???</span>
00055 <span class="comment">// Matrix + Matrix</span>
00056 <span class="comment">// Matrix - Matrix</span>
00057 <span class="comment">// mult_element(A,B) - element by element multiplication</span>
00058 <span class="comment">// transpose(A) - matrix transposition</span>
00059 <span class="comment">// Matrix * Matrix (also matmult)</span>
00060 <span class="comment">// matmult(C, B, A) - result stored in C</span>
00061 <span class="comment">// Matrix * Vector (also matmult)</span>
00062 
00063 <span class="comment">// Chris Siefert Additions:</span>
00064 <span class="comment">// row(i) - returns a Vector containing the ith row.</span>
00065 <span class="comment">// col(i) - returns a Vector containing the ith column.</span>
00066 <span class="comment">// Matrix * Scalar, Scalar * Matrix (also scalmult, 1st form only).</span>
00067 <span class="comment">// Vector * Matrix (also matmult).  Pretends vector is a row vector.</span>
00068 <span class="comment">//</span>
00069 <span class="comment">// Modified 7/00 by Anne Shepherd to allow for different implementations</span>
00070 <span class="comment">// of the operators new and new[].  If your compiler does not support the</span>
00071 <span class="comment">// ANSI Standard try-catch syntax, compile with -DDOLD_ALLOC flag or just </span>
00072 <span class="comment">// #define DOLD_ALLOC in your file before including our files.</span>
00073 
00074 <span class="preprocessor">#ifndef CMAT_H</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#define CMAT_H</span>
00076 <span class="preprocessor"></span>
00077 <span class="preprocessor">#ifndef DOLD_ALLOC</span>
00078 <span class="preprocessor"></span><span class="preprocessor">#include &lt;new&gt;</span>
00079 <span class="preprocessor">#endif</span>
00080 <span class="preprocessor"></span>
00081 <span class="preprocessor">#include "vec.h"</span>
00082 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
00083 <span class="preprocessor">#include &lt;cassert&gt;</span>
00084 
00085 <span class="preprocessor">#include &lt;iostream&gt;</span>
00086 <span class="preprocessor">#ifdef TNT_USE_REGIONS</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#include "region2d.h"</span>
00088 <span class="preprocessor">#endif</span>
00089 <span class="preprocessor"></span>
00090 <span class="preprocessor">#include &lt;iomanip&gt;</span>
00091 <span class="preprocessor">#define D_PRECISION 16</span>
00092 <span class="preprocessor"></span>
00093 
00094 <span class="comment">//namespace TNT</span>
00095 <span class="comment">//{</span>
00096 <span class="keyword">typedef</span> <span class="keywordtype">long</span> Subscript;
00097 
00098 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00099 <span class="keyword">class </span>Matrix 
00100 {
00101 
00102 
00103   <span class="keyword">public</span>:
00104 
00105     <span class="keyword">typedef</span> Subscript   size_type;
00106     <span class="keyword">typedef</span>         T   value_type;
00107     <span class="keyword">typedef</span>         T   element_type;
00108     <span class="keyword">typedef</span>         T*  pointer;
00109     <span class="keyword">typedef</span>         T*  iterator;
00110     <span class="keyword">typedef</span>         T&amp;  reference;
00111     <span class="keyword">typedef</span> <span class="keyword">const</span>   T*  const_iterator;
00112     <span class="keyword">typedef</span> <span class="keyword">const</span>   T&amp;  const_reference;
00113 
00114     Subscript lbound()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 1;}
00115  
00116   <span class="keyword">protected</span>:
00117     Subscript m_;
00118     Subscript n_;
00119     Subscript mn_;      <span class="comment">// total size</span>
00120     T* v_;                  
00121     T** row_;           
00122     T* vm1_ ;       <span class="comment">// these point to the same data, but are 1-based </span>
00123     T** rowm1_;
00124 
00125     <span class="comment">// internal helper function to create the array</span>
00126     <span class="comment">// of row pointers</span>
00127 
00128     <span class="keywordtype">void</span> initialize(Subscript M, Subscript N)
00129     {
00130         mn_ = M*N;
00131         m_ = M;
00132         n_ = N;
00133 
00134 <span class="preprocessor">#ifdef DOLD_ALLOC</span>
00135 <span class="preprocessor"></span>        v_ = <span class="keyword">new</span> T[mn_]; 
00136         row_ = <span class="keyword">new</span> T*[M];
00137         rowm1_ = <span class="keyword">new</span> T*[M];
00138 
00139         assert(v_  != NULL);
00140         assert(row_  != NULL);
00141         assert(rowm1_ != NULL);
00142 <span class="preprocessor">#else</span>
00143 <span class="preprocessor"></span>        <span class="keywordflow">try</span>{
00144           v_ = <span class="keyword">new</span> T[mn_]; 
00145         } <span class="comment">//try</span>
00146         <span class="keywordflow">catch</span> ( bad_alloc exception ) {      
00147           cerr &lt;&lt; <span class="stringliteral">"Memory allocation failed in file cppmat.h, method initialize()."</span>
00148                &lt;&lt; <span class="stringliteral">"Exiting with value 1.\n"</span>;
00149           exit(1);
00150         } <span class="comment">//catch</span>
00151 
00152         <span class="keywordflow">try</span>{
00153           row_ = <span class="keyword">new</span> T*[M];
00154         } <span class="comment">//try</span>
00155         <span class="keywordflow">catch</span> (bad_alloc exception) {      
00156           cerr &lt;&lt; <span class="stringliteral">"Memory allocation failed in file cppmat.h, method initialize()."</span>
00157                &lt;&lt; <span class="stringliteral">"Exiting with value 1.\n"</span>;
00158           exit(1);
00159         } <span class="comment">//catch</span>
00160 
00161         <span class="keywordflow">try</span>{
00162           rowm1_ = <span class="keyword">new</span> T*[M];
00163         } <span class="comment">//try</span>
00164         <span class="keywordflow">catch</span> ( bad_alloc exception ) {      
00165           cerr &lt;&lt; <span class="stringliteral">"Memory allocation failed in file cppmat.h, method initialize()."</span>
00166                &lt;&lt; <span class="stringliteral">"Exiting with value 1.\n"</span>;
00167           exit(1);
00168         } <span class="comment">//catch</span>
00169 <span class="preprocessor">#endif</span>
00170 <span class="preprocessor"></span>
00171         T* p = v_;              
00172         vm1_ = v_ - 1;
00173         <span class="keywordflow">for</span> (Subscript i=0; i&lt;M; i++)
00174         {
00175             row_[i] = p;
00176             rowm1_[i] = p-1;
00177             p += N ;
00178             
00179         }
00180 
00181         rowm1_ -- ;     <span class="comment">// compensate for 1-based offset</span>
00182     }
00183    
00184     <span class="keywordtype">void</span> copy(<span class="keyword">const</span> T*  v)
00185     {
00186         Subscript N = m_ * n_;
00187         Subscript i;
00188 
00189 <span class="preprocessor">#ifdef TNT_UNROLL_LOOPS</span>
00190 <span class="preprocessor"></span>        Subscript Nmod4 = N &amp; 3;
00191         Subscript N4 = N - Nmod4;
00192 
00193         <span class="keywordflow">for</span> (i=0; i&lt;N4; i+=4)
00194         {
00195             v_[i] = v[i];
00196             v_[i+1] = v[i+1];
00197             v_[i+2] = v[i+2];
00198             v_[i+3] = v[i+3];
00199         }
00200 
00201         <span class="keywordflow">for</span> (i=N4; i&lt; N; i++)
00202             v_[i] = v[i];
00203 <span class="preprocessor">#else</span>
00204 <span class="preprocessor"></span>
00205         <span class="keywordflow">for</span> (i=0; i&lt; N; i++)
00206             v_[i] = v[i];
00207 <span class="preprocessor">#endif      </span>
00208 <span class="preprocessor"></span>    }
00209 
00210     <span class="keywordtype">void</span> set(<span class="keyword">const</span> T&amp; val)
00211     {
00212         Subscript N = m_ * n_;
00213         Subscript i;
00214 
00215 <span class="preprocessor">#ifdef TNT_UNROLL_LOOPS</span>
00216 <span class="preprocessor"></span>        Subscript Nmod4 = N &amp; 3;
00217         Subscript N4 = N - Nmod4;
00218 
00219         <span class="keywordflow">for</span> (i=0; i&lt;N4; i+=4)
00220         {
00221             v_[i] = val;
00222             v_[i+1] = val;
00223             v_[i+2] = val;
00224             v_[i+3] = val; 
00225         }
00226 
00227         <span class="keywordflow">for</span> (i=N4; i&lt; N; i++)
00228             v_[i] = val;
00229 <span class="preprocessor">#else</span>
00230 <span class="preprocessor"></span>
00231         <span class="keywordflow">for</span> (i=0; i&lt; N; i++)
00232             v_[i] = val;
00233         
00234 <span class="preprocessor">#endif      </span>
00235 <span class="preprocessor"></span>    }
00236     
00237 
00238     
00239     <span class="keywordtype">void</span> destroy()
00240     {     
00241         <span class="comment">/* do nothing, if no memory has been previously allocated */</span>
00242         <span class="keywordflow">if</span> (v_ == NULL) return ;
00243 
00244         <span class="comment">/* if we are here, then matrix was previously allocated */</span>
00245         <span class="keywordflow">if</span> (v_ != NULL) <span class="keyword">delete</span> [] (v_);     
00246         <span class="keywordflow">if</span> (row_ != NULL) <span class="keyword">delete</span> [] (row_);
00247 
00248         <span class="comment">/* return rowm1_ back to original value */</span>
00249         rowm1_ ++;
00250         <span class="keywordflow">if</span> (rowm1_ != NULL ) <span class="keyword">delete</span> [] (rowm1_);
00251     }
00252 
00253 
00254   <span class="keyword">public</span>:
00255 
00256     operator T**(){ <span class="keywordflow">return</span>  row_; }
00257     operator T**()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> row_; }
00258 
00259 
00260     Subscript size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mn_; }
00261 
00262     <span class="comment">// constructors</span>
00263 
00264     Matrix() : m_(0), n_(0), mn_(0), v_(0), row_(0), vm1_(0), rowm1_(0) {};
00265 
00266     Matrix(<span class="keyword">const</span> Matrix&lt;T&gt; &amp;A)
00267     {
00268         initialize(A.m_, A.n_);
00269         copy(A.v_);
00270     }
00271 
00272     Matrix(Subscript M, Subscript N, <span class="keyword">const</span> T&amp; value = T(0))
00273     {
00274         initialize(M,N);
00275         set(value);
00276     }
00277 
00278     Matrix(Subscript M, Subscript N, <span class="keyword">const</span> T* v)
00279     {
00280         initialize(M,N);
00281         copy(v);
00282     }
00283 
00284     Matrix(Subscript M, Subscript N, <span class="keywordtype">char</span> *s)
00285     {
00286         initialize(M,N);   
00287 
00288         istringstream ins(s);        
00289         Subscript i, j;
00290 
00291         <span class="keywordflow">for</span> (i=0; i&lt;M; i++)
00292             <span class="keywordflow">for</span> (j=0; j&lt;N; j++)
00293                 ins &gt;&gt; row_[i][j];
00294     }
00295 
00296     <span class="comment">// destructor</span>
00297     <span class="comment">//</span>
00298     ~Matrix()
00299     {
00300         destroy();
00301     }
00302 
00303 
00304     <span class="comment">// reallocating</span>
00305     <span class="comment">//</span>
00306     Matrix&lt;T&gt;&amp; newsize(Subscript M, Subscript N)
00307     {
00308         <span class="keywordflow">if</span> (num_rows() == M &amp;&amp; num_cols() == N)
00309             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00310 
00311         destroy();
00312         initialize(M,N);
00313         
00314         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00315     }
00316 
00317 
00318 
00319 
00320     <span class="comment">// assignments</span>
00321     <span class="comment">//</span>
00322     Matrix&lt;T&gt;&amp; operator=(<span class="keyword">const</span> Matrix&lt;T&gt; &amp;A)
00323     {
00324         <span class="keywordflow">if</span> (v_ == A.v_)
00325             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00326 
00327         <span class="keywordflow">if</span> (m_ == A.m_  &amp;&amp; n_ == A.n_)      <span class="comment">// no need to re-alloc</span>
00328             copy(A.v_);
00329 
00330         <span class="keywordflow">else</span>
00331         {
00332             destroy();
00333             initialize(A.m_, A.n_);
00334             copy(A.v_);
00335         }
00336 
00337         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00338     }
00339         
00340     Matrix&lt;T&gt;&amp; operator=(<span class="keyword">const</span> T&amp; scalar)
00341     { 
00342         set(scalar); 
00343         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00344     }
00345 
00346 
00347     Subscript dim(Subscript d)<span class="keyword"> const </span>
00348 <span class="keyword">    </span>{
00349 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00350 <span class="preprocessor"></span>       assert( d &gt;= 1);
00351         assert( d &lt;= 2);
00352 <span class="preprocessor">#endif</span>
00353 <span class="preprocessor"></span>        <span class="keywordflow">return</span> (d==1) ? m_ : ((d==2) ? n_ : 0); 
00354     }
00355 
00356     Subscript num_rows()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_; }
00357     Subscript num_cols()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> n_; }
00358 
00359 
00360   <span class="keyword">inline</span> T* operator[](Subscript i)
00361     {
00362 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00363 <span class="preprocessor"></span>        assert(0&lt;=i);
00364         assert(i &lt; m_) ;
00365 <span class="preprocessor">#endif</span>
00366 <span class="preprocessor"></span>        <span class="keywordflow">return</span> row_[i];
00367     }
00368 
00369 <span class="comment">/*START - cmsief************************/</span>
00370   
00371   <span class="comment">/*This is a Chris Siefert original that attempts to return a vector*/</span>
00372   <span class="keyword">inline</span> Vector&lt;T&gt; row (Subscript i)<span class="keyword"> const</span>
00373 <span class="keyword">    </span>{
00374 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00375 <span class="preprocessor"></span>     assert(0&lt;=i);
00376      assert(i &lt; m_) ;
00377 <span class="preprocessor">#endif</span>
00378 <span class="preprocessor"></span>     Vector&lt;T&gt;temp(n_,row_[i]);
00379      <span class="keywordflow">return</span> (temp);     
00380     }
00381 
00382   <span class="keyword">inline</span> Vector&lt;T&gt; col (Subscript i)<span class="keyword"> const</span>
00383 <span class="keyword">    </span>{
00384 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00385 <span class="preprocessor"></span>     assert(0&lt;=i);
00386      assert(i &lt; n_) ;
00387 <span class="preprocessor">#endif  </span>
00388 <span class="preprocessor"></span>     Vector&lt;T&gt;temp(m_);
00389      <span class="keywordflow">for</span>(<span class="keywordtype">long</span> f=0;f&lt;m_;f++) temp[f]=row_[f][i];
00390      <span class="keywordflow">return</span> (temp);
00391     }
00392 <span class="comment">/*END - cmsief************************/</span>
00393   
00394   <span class="keyword">inline</span> <span class="keyword">const</span> T* operator[](Subscript i)<span class="keyword"> const</span>
00395 <span class="keyword">    </span>{
00396 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00397 <span class="preprocessor"></span>      assert(0&lt;=i);
00398       assert(i &lt; m_) ;
00399 <span class="preprocessor">#endif</span>
00400 <span class="preprocessor"></span>      <span class="keywordflow">return</span> row_[i];
00401     }
00402 
00403     <span class="comment">/*  Changed all this from being 1-based to good ol' C-type</span>
00404 <span class="comment">     *  0-based indexing.</span>
00405 <span class="comment">     *     pls, 5/15/03</span>
00406 <span class="comment">     */</span>
00407 
00408   <span class="comment">// this is for a sanity check later---using an old version of this</span>
00409   <span class="comment">// file will result in off-by-1 errors and give incorrect results.</span>
00410 <span class="preprocessor">#define _changed_f_indexing_to_c_pls</span>
00411 <span class="preprocessor"></span>
00412     <span class="keyword">inline</span> reference operator()(Subscript i)
00413     { 
00414 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00415 <span class="preprocessor"></span>        assert(1&lt;=i);
00416         assert(i &lt;= mn_) ;
00417 <span class="preprocessor">#endif</span>
00418 <span class="preprocessor"></span>        <span class="comment">//return vm1_[i];</span>
00419         <span class="keywordflow">return</span> v_[i]; 
00420     }
00421 
00422     <span class="keyword">inline</span> const_reference operator()(Subscript i)<span class="keyword"> const</span>
00423 <span class="keyword">    </span>{ 
00424 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00425 <span class="preprocessor"></span>        assert(1&lt;=i);
00426         assert(i &lt;= mn_) ;
00427 <span class="preprocessor">#endif</span>
00428 <span class="preprocessor"></span>        <span class="comment">//return vm1_[i]; </span>
00429         <span class="keywordflow">return</span> v_[i]; 
00430     }
00431 
00432 
00433     <span class="keyword">inline</span> reference operator()(Subscript i, Subscript j)
00434     { 
00435 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00436 <span class="preprocessor"></span>        assert(1&lt;=i);
00437         assert(i &lt;= m_) ;
00438         assert(1&lt;=j);
00439         assert(j &lt;= n_);
00440 <span class="preprocessor">#endif</span>
00441 <span class="preprocessor"></span>        <span class="comment">//return  rowm1_[i][j]; </span>
00442         <span class="keywordflow">return</span>  row_[i][j]; 
00443     }
00444 
00445 
00446     
00447     <span class="keyword">inline</span> const_reference operator() (Subscript i, Subscript j)<span class="keyword"> const</span>
00448 <span class="keyword">    </span>{
00449 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00450 <span class="preprocessor"></span>        assert(1&lt;=i);
00451         assert(i &lt;= m_) ;
00452         assert(1&lt;=j);
00453         assert(j &lt;= n_);
00454 <span class="preprocessor">#endif</span>
00455 <span class="preprocessor"></span>        <span class="comment">//return  rowm1_[i][j]; </span>
00456         <span class="keywordflow">return</span>  row_[i][j]; 
00457     }
00458 
00459     <span class="comment">/*  end P.L. Shepherd hacks to C-ize the () operators */</span>
00460 
00461 <span class="preprocessor">#ifdef OLD_LIBC</span>
00462 <span class="preprocessor"></span>  <span class="keyword">friend</span> istream &amp; operator&gt;&gt;(istream &amp;s, Matrix&lt;T&gt; &amp;A);
00463 <span class="preprocessor">#else</span>
00464 <span class="preprocessor"></span>  <span class="comment">//  template&lt;class T&gt;</span>
00465   <span class="keyword">friend</span> istream &amp; operator&gt;&gt;&lt;&gt;(istream &amp;s, Matrix&lt;T&gt; &amp;A);
00466 <span class="preprocessor">#endif  </span>
00467 <span class="preprocessor"></span>  <span class="comment">//        friend std::istream &amp; operator&gt;&gt;(std::istream &amp;s, Matrix&lt;T&gt; &amp;A);</span>
00468 
00469 <span class="preprocessor">#ifdef TNT_USE_REGIONS</span>
00470 <span class="preprocessor"></span>
00471     <span class="keyword">typedef</span> Region2D&lt;Matrix&lt;T&gt; &gt; Region;
00472     
00473 
00474     Region operator()(<span class="keyword">const</span> Index1D &amp;I, <span class="keyword">const</span> Index1D &amp;J)
00475     {
00476         <span class="keywordflow">return</span> Region(*<span class="keyword">this</span>, I,J);
00477     }
00478 
00479 
00480     <span class="keyword">typedef</span> const_Region2D&lt; Matrix&lt;T&gt; &gt; const_Region;
00481     const_Region operator()(<span class="keyword">const</span> Index1D &amp;I, <span class="keyword">const</span> Index1D &amp;J)<span class="keyword"> const</span>
00482 <span class="keyword">    </span>{
00483         <span class="keywordflow">return</span> const_Region(*<span class="keyword">this</span>, I,J);
00484     }
00485 
00486 <span class="preprocessor">#endif</span>
00487 <span class="preprocessor"></span>
00488 
00489 };
00490 
00491 
00492 <span class="comment">/* ***************************  I/O  ********************************/</span>
00493 <span class="comment">//std::ostream&amp; operator&lt;&lt;(std::ostream &amp;s, const Matrix&lt;T&gt; &amp;A)</span>
00494 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00495 ostream&amp; operator&lt;&lt;(ostream &amp;s, const Matrix&lt;T&gt; &amp;A)
00496 {
00497     Subscript M=A.num_rows();
00498     Subscript N=A.num_cols();
00499 
00500     s &lt;&lt; M &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; N &lt;&lt; <span class="stringliteral">"\n"</span>;
00501 
00502     <span class="keywordflow">for</span> (Subscript i=0; i&lt;M; i++)
00503     {
00504         <span class="keywordflow">for</span> (Subscript j=0; j&lt;N; j++)
00505         {
00506           s &lt;&lt;setprecision(D_PRECISION)&lt;&lt; A[i][j] &lt;&lt; <span class="stringliteral">" "</span>;
00507         }
00508         s &lt;&lt; <span class="stringliteral">"\n"</span>;
00509     }
00510 
00511 
00512     <span class="keywordflow">return</span> s;
00513 }
00514 <span class="comment">//std::istream&amp; operator&gt;&gt;(std::istream &amp;s, Matrix&lt;T&gt; &amp;A)</span>
00515 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00516 istream&amp; operator&gt;&gt;(istream &amp;s, Matrix&lt;T&gt; &amp;A)
00517 {
00518 
00519     Subscript M, N;
00520 
00521     s &gt;&gt; M &gt;&gt; N;
00522 
00523     <span class="keywordflow">if</span> ( !(M == A.m_ &amp;&amp; N == A.n_) )
00524     {
00525         A.destroy();
00526         A.initialize(M,N);
00527     }
00528 
00529 
00530     <span class="keywordflow">for</span> (Subscript i=0; i&lt;M; i++)
00531         <span class="keywordflow">for</span> (Subscript j=0; j&lt;N; j++)
00532         {
00533             s &gt;&gt;  A[i][j];
00534         }
00535 
00536 
00537     <span class="keywordflow">return</span> s;
00538 }
00539 
00540 <span class="comment">// *******************[ basic matrix algorithms ]***************************</span>
00541 
00542 
00543 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00544 Matrix&lt;T&gt; operator+(<span class="keyword">const</span> Matrix&lt;T&gt; &amp;A, 
00545     <span class="keyword">const</span> Matrix&lt;T&gt; &amp;B)
00546 {
00547     Subscript M = A.num_rows();
00548     Subscript N = A.num_cols();
00549 
00550     assert(M==B.num_rows());
00551     assert(N==B.num_cols());
00552 
00553     Matrix&lt;T&gt; tmp(M,N);
00554     Subscript i,j;
00555 
00556     <span class="keywordflow">for</span> (i=0; i&lt;M; i++)
00557         <span class="keywordflow">for</span> (j=0; j&lt;N; j++)
00558             tmp[i][j] = A[i][j] + B[i][j];
00559 
00560     <span class="keywordflow">return</span> tmp;
00561 }
00562 
00563 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00564 Matrix&lt;T&gt; operator-(<span class="keyword">const</span> Matrix&lt;T&gt; &amp;A, 
00565     <span class="keyword">const</span> Matrix&lt;T&gt; &amp;B)
00566 {
00567     Subscript M = A.num_rows();
00568     Subscript N = A.num_cols();
00569 
00570     assert(M==B.num_rows());
00571     assert(N==B.num_cols());
00572 
00573     Matrix&lt;T&gt; tmp(M,N);
00574     Subscript i,j;
00575 
00576     <span class="keywordflow">for</span> (i=0; i&lt;M; i++)
00577         <span class="keywordflow">for</span> (j=0; j&lt;N; j++)
00578             tmp[i][j] = A[i][j] - B[i][j];
00579 
00580     <span class="keywordflow">return</span> tmp;
00581 }
00582 
00583 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00584 Matrix&lt;T&gt; mult_element(<span class="keyword">const</span> Matrix&lt;T&gt; &amp;A, 
00585     <span class="keyword">const</span> Matrix&lt;T&gt; &amp;B)
00586 {
00587     Subscript M = A.num_rows();
00588     Subscript N = A.num_cols();
00589 
00590     assert(M==B.num_rows());
00591     assert(N==B.num_cols());
00592 
00593     Matrix&lt;T&gt; tmp(M,N);
00594     Subscript i,j;
00595 
00596     <span class="keywordflow">for</span> (i=0; i&lt;M; i++)
00597         <span class="keywordflow">for</span> (j=0; j&lt;N; j++)
00598             tmp[i][j] = A[i][j] * B[i][j];
00599 
00600     <span class="keywordflow">return</span> tmp;
00601 }
00602 
00603 
00604 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00605 Matrix&lt;T&gt; transpose(<span class="keyword">const</span> Matrix&lt;T&gt; &amp;A)
00606 {
00607     Subscript M = A.num_rows();
00608     Subscript N = A.num_cols();
00609 
00610     Matrix&lt;T&gt; S(N,M);
00611     Subscript i, j;
00612 
00613     <span class="keywordflow">for</span> (i=0; i&lt;M; i++)
00614         <span class="keywordflow">for</span> (j=0; j&lt;N; j++)
00615             S[j][i] = A[i][j];
00616 
00617     <span class="keywordflow">return</span> S;
00618 }
00619 
00620 
00621     
00622 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00623 <span class="keyword">inline</span> Matrix&lt;T&gt; matmult(<span class="keyword">const</span> Matrix&lt;T&gt;  &amp;A, 
00624     <span class="keyword">const</span> Matrix&lt;T&gt; &amp;B)
00625 {
00626 
00627 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00628 <span class="preprocessor"></span>    assert(A.num_cols() == B.num_rows());
00629 <span class="preprocessor">#endif</span>
00630 <span class="preprocessor"></span>
00631     Subscript M = A.num_rows();
00632     Subscript N = A.num_cols();
00633     Subscript K = B.num_cols();
00634 
00635     Matrix&lt;T&gt; tmp(M,K);
00636     T sum;
00637 
00638     <span class="keywordflow">for</span> (Subscript i=0; i&lt;M; i++)
00639     <span class="keywordflow">for</span> (Subscript k=0; k&lt;K; k++)
00640     {
00641         sum = 0;
00642         <span class="keywordflow">for</span> (Subscript j=0; j&lt;N; j++)
00643             sum = sum +  A[i][j] * B[j][k];
00644 
00645         tmp[i][k] = sum; 
00646     }
00647 
00648     <span class="keywordflow">return</span> tmp;
00649 }
00650 
00651 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00652 <span class="keyword">inline</span> Matrix&lt;T&gt; operator*(<span class="keyword">const</span> Matrix&lt;T&gt;  &amp;A, 
00653     <span class="keyword">const</span> Matrix&lt;T&gt; &amp;B)
00654 {
00655   <span class="keywordflow">return</span> matmult(A,B);
00656 }
00657 
00658 <span class="comment">/*More Chris Siefert additions*/</span>
00659 
00660 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00661 <span class="keyword">inline</span> Matrix&lt;T&gt; scalmult(<span class="keyword">const</span> Matrix&lt;T&gt;  &amp;A, 
00662     <span class="keyword">const</span> T &amp;x)
00663 {
00664   Matrix&lt;T&gt; tmp=A;
00665   Subscript M = A.num_rows();
00666   Subscript N = A.num_cols();
00667 
00668   <span class="keywordflow">for</span>(Subscript i=0;i&lt;M;i++)
00669     <span class="keywordflow">for</span>(Subscript j=0;j&lt;N;j++)
00670       tmp[i][j]*=x;
00671   <span class="keywordflow">return</span> tmp;
00672 }
00673 
00674 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00675 <span class="keyword">inline</span> Matrix&lt;T&gt; operator*(<span class="keyword">const</span> Matrix&lt;T&gt;  &amp;A, 
00676     <span class="keyword">const</span> T &amp;x)
00677 {
00678   <span class="keywordflow">return</span> scalmult(A,x);
00679 }
00680 
00681 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00682 <span class="keyword">inline</span> Matrix&lt;T&gt; operator*(<span class="keyword">const</span> T &amp;x, 
00683     <span class="keyword">const</span> Matrix&lt;T&gt; &amp;A)
00684 {
00685   <span class="keywordflow">return</span> scalmult(A,x);
00686 }
00687 
00688 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00689 Vector&lt;T&gt; matmult(<span class="keyword">const</span> Vector&lt;T&gt; &amp;x, <span class="keyword">const</span> Matrix&lt;T&gt; &amp;A) {
00690   <span class="comment">/*pretends that x is a row-vector*/</span>
00691 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00692 <span class="preprocessor"></span>    assert(A.num_rows() == x.dim());
00693 <span class="preprocessor">#endif</span>
00694 <span class="preprocessor"></span>
00695     Subscript M = A.num_rows();
00696     Subscript N = A.num_cols();
00697 
00698     Vector&lt;T&gt; tmp(N);
00699     T sum;
00700 
00701     <span class="keywordflow">for</span> (Subscript i=0; i&lt;N; i++)
00702     {
00703         sum = 0;
00704         <span class="comment">//        Vector&lt;T&gt; coli=A.col(i);</span>
00705         <span class="keywordflow">for</span> (Subscript j=0; j&lt;M; j++)
00706             sum = sum +  A[j][i] * x[j];
00707 
00708         tmp[i] = sum; 
00709     }
00710 
00711     <span class="keywordflow">return</span> tmp;
00712 
00713 }<span class="comment">/*end matmult*/</span>
00714 
00715 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00716 <span class="keyword">inline</span> Vector&lt;T&gt; operator*(<span class="keyword">const</span> Vector&lt;T&gt; &amp;x, 
00717                            <span class="keyword">const</span> Matrix&lt;T&gt; &amp;A)
00718 {
00719   <span class="keywordflow">return</span> matmult(x,A);
00720 }
00721 
00722 
00723 <span class="comment">/*end Chris Siefert additions*/</span>
00724 
00725 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00726 <span class="keyword">inline</span> <span class="keywordtype">int</span> matmult(Matrix&lt;T&gt;&amp; C, <span class="keyword">const</span> Matrix&lt;T&gt;  &amp;A, 
00727     <span class="keyword">const</span> Matrix&lt;T&gt; &amp;B)
00728 {
00729 
00730     assert(A.num_cols() == B.num_rows());
00731 
00732     Subscript M = A.num_rows();
00733     Subscript N = A.num_cols();
00734     Subscript K = B.num_cols();
00735 
00736     C.newsize(M,K);
00737 
00738     T sum;
00739 
00740     <span class="keyword">const</span> T* row_i;
00741     <span class="keyword">const</span> T* col_k;
00742 
00743     <span class="keywordflow">for</span> (Subscript i=0; i&lt;M; i++)
00744     <span class="keywordflow">for</span> (Subscript k=0; k&lt;K; k++)
00745     {
00746         row_i  = &amp;(A[i][0]);
00747         col_k  = &amp;(B[0][k]);
00748         sum = 0;
00749         <span class="keywordflow">for</span> (Subscript j=0; j&lt;N; j++)
00750         {
00751             sum  += *row_i * *col_k;
00752             row_i++;
00753             col_k += K;
00754         }
00755         C[i][k] = sum; 
00756     }
00757 
00758     <span class="keywordflow">return</span> 0;
00759 }
00760 
00761 
00762 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00763 Vector&lt;T&gt; matmult(<span class="keyword">const</span> Matrix&lt;T&gt;  &amp;A, <span class="keyword">const</span> Vector&lt;T&gt; &amp;x)
00764 {
00765 
00766 <span class="preprocessor">#ifdef TNT_BOUNDS_CHECK</span>
00767 <span class="preprocessor"></span>    assert(A.num_cols() == x.dim());
00768 <span class="preprocessor">#endif</span>
00769 <span class="preprocessor"></span>
00770     Subscript M = A.num_rows();
00771     Subscript N = A.num_cols();
00772 
00773     Vector&lt;T&gt; tmp(M);
00774     T sum;
00775 
00776     <span class="keywordflow">for</span> (Subscript i=0; i&lt;M; i++)
00777     {
00778         sum = 0;
00779         <span class="keyword">const</span> T* rowi = A[i];
00780         <span class="keywordflow">for</span> (Subscript j=0; j&lt;N; j++)
00781             sum = sum +  rowi[j] * x[j];
00782 
00783         tmp[i] = sum; 
00784     }
00785 
00786     <span class="keywordflow">return</span> tmp;
00787 }
00788 
00789 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00790 <span class="keyword">inline</span> Vector&lt;T&gt; operator*(<span class="keyword">const</span> Matrix&lt;T&gt;  &amp;A, <span class="keyword">const</span> Vector&lt;T&gt; &amp;x)
00791 {
00792     <span class="keywordflow">return</span> matmult(A,x);
00793 }
00794 
00795 <span class="comment">//} // namespace TNT</span>
00796 
00797 <span class="preprocessor">#endif</span>
00798 <span class="preprocessor"></span><span class="comment">// CMAT_H</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Sep 25 17:37:40 2007 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
